{"meta":{"title":"云逸","subtitle":null,"description":"记录生活","author":"云逸","url":"https://ioufev.com"},"pages":[{"title":"关于","date":"2019-01-18T08:34:29.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"about/index.html","permalink":"https://ioufev.com/about/index.html","excerpt":"","text":"我就是我"},{"title":"标签","date":"2019-01-18T08:33:05.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"tags/index.html","permalink":"https://ioufev.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-01-18T08:33:57.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"categories/index.html","permalink":"https://ioufev.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"高并发分布式架构演进之路","slug":"高并发分布式架构演进之路","date":"2019-12-30T06:29:38.000Z","updated":"2021-08-17T13:21:19.714Z","comments":true,"path":"2019/12/30/gao-bing-fa-fen-bu-shi-jia-gou-yan-jin-zhi-lu/","link":"","permalink":"https://ioufev.com/2019/12/30/gao-bing-fa-fen-bu-shi-jia-gou-yan-jin-zhi-lu/","excerpt":"服务端高并发分布式架构演进之路","text":"服务端高并发分布式架构演进之路 原文作者：huashiou原文标题：服务端高并发分布式架构演进之路原文地址：https://segmentfault.com/a/1190000018626163 概述本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。 特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径 基本概念在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍： 分布式系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上 高可用系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性 集群一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性 负载均衡请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的 正向代理和反向代理系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。 架构演进单机架构 以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。 随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务 第一次演进：Tomcat与数据库分开部署 Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。 随着用户数的增长，并发读写数据库成为瓶颈 第二次演进：引入本地缓存和分布式缓存 在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。 缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢 第三次演进：引入反向代理实现负载均衡 在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。 反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈 第四次演进：数据库读写分离 把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。 业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能 第五次演进：数据库按业务分库 把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。 随着用户数的增长，单机的写库会逐渐会达到性能瓶颈 第六次演进：把大表拆分为小表 比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。 这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。 目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。 数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈 第七次演进：使用LVS或F5来使多个Nginx负载均衡 由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。 此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。 由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同 第八次演进：通过DNS轮询实现机房间的负载均衡 在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。 随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求 第九次演进：引入NoSQL数据库和搜索引擎等技术 当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。 当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。 引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难 第十次演进：大应用拆分为小应用 按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。 不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级 第十一次演进：复用的功能抽离成微服务 如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。 不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异 通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。 业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理 目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。 在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。 使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低 第十四次演进：以云平台承载系统 系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。 所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念： IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面； PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护； SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。 至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论 架构设计总结架构的调整是否必须按照上述演变路径进行？不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。 对于将要实施的系统，架构应该设计到什么程度？对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。 服务端架构和大数据架构有什么区别？所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。 有没有一些架构设计的原则？ N+1设计。系统中的每个组件都应做到没有单点故障； 回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本； 禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能； 监控设计。在设计阶段就要考虑监控的手段； 多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用； 采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难； 资源隔离设计。应避免单一业务占用全部资源； 架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题； 非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品； 使用商用硬件。商用硬件能有效降低硬件故障的机率； 快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险； 无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://ioufev.com/tags/架构/"}]},{"title":"oracle API脚本创建实例","slug":"oracle API脚本创建实例","date":"2019-12-23T11:43:18.584Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/12/23/oracle-api-jiao-ben-chuang-jian-shi-li/","link":"","permalink":"https://ioufev.com/2019/12/23/oracle-api-jiao-ben-chuang-jian-shi-li/","excerpt":"oracle 使用 API 脚本创建实例","text":"oracle 使用 API 脚本创建实例 参考：https://www.bobobk.com/612.html 机器：准备一台机器，我用的腾讯云的centos7.6 Shell工具：FinalShell FinalShell 鼠标选中内容后 第一个图标：只复制 第二个图标：复制并且粘贴 安装oci-cli 参考：https://docs.cloud.oracle.com/iaas/Content/API/SDKDocs/cliinstall.htm 安装oci-cli 123456789101112131415161718[root@VM_0_12_centos ~]# bash -c \"$(curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh)\"## 一堆代码===&gt; Modify profile to update your $PATH and enable shell/tab completion now? (Y/n): y## 一些提示-- ** Run `exec -l $SHELL` to restart your shell. **-- -- Installation successful.-- Run the CLI with /root/bin/oci --help## 按照提示使oci生效[root@VM_0_12_centos ~]# exec -l $SHELL## 查看oci是否生效[root@VM_0_12_centos ~]# oci -v2.6.9 oci-cli其他命令 12345## 升级oci-clipip install oci-cli --upgrade## 卸载oci-clipip uninstall oci-cli 配置oci 获得用户OCID：ocid1.user.oc1..aaaaaaaajrz7kqwo2tz5esslpdxc75nkfs4cbfwccq5xqt6ql2oinkh32e4a 获得租户OCID：ocid1.tenancy.oc1..aaaaaaaavb77g5bgee2venclnxhonn3zjvb6xafodnx7uuya3edwq6fgd46a 1234567891011121314151617181920212223242526272829303132333435363738394041[root@VM_0_12_centos ~]# oci setup config## 一堆代码Enter a location for your config [/root/.oci/config]: ## 输入用户IDEnter a user OCID: ocid1.user.oc1..aaaaaaaajrz7kqwo2tz5esslpdxc75nkfs4cbfwccq5xqt6ql2oinkh32e4a## 输入租户IDEnter a tenancy OCID: ocid1.tenancy.oc1..aaaaaaaavb77g5bgee2venclnxhonn3zjvb6xafodnx7uuya3edwq6fgd46a## 输入区域，自然是韩国Enter a region (e.g. ap-mumbai-1, ap-seoul-1, ap-sydney-1, ap-tokyo-1, ca-toronto-1, eu-frankfurt-1, eu-zurich-1, sa-saopaulo-1, uk-london-1, us-ashburn-1, us-gov-ashburn-1, us-gov-chicago-1, us-gov-phoenix-1, us-langley-1, us-luke-1, us-phoenix-1): ap-seoul-1## 问是否生成密钥对，是，yDo you want to generate a new RSA key pair? (If you decline you will be asked to supply the path to an existing key.) [Y/n]: yEnter a directory for your keys to be created [/root/.oci]: Enter a name for your key [oci_api_key]: ## 公钥路径Public key written to: /root/.oci/oci_api_key_public.pem## 问是否设置私钥密码，当然不要，默认回车Enter a passphrase for your private key (empty for no passphrase): ## 私钥路径Private key written to: /root/.oci/oci_api_key.pem## 一堆代码## 查看公钥[root@VM_0_12_centos ~]# more /root/.oci/oci_api_key_public.pem-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzXqJQA8yhFaL4AshcHRMcTRxore9suSn8gsM+N19AMx8rv1I538bPnMtZJgFKlyUwDlcpWbfVTwycJIPfwiahvpUlS+On9nsxrP6FfS7qtqdc9BleUHAL9qAQgHFrRkt2B4WESvrmIeNb08I6L74xggWQXFnU9N4LZh4hQIN+dk/Nso6Y8sGEqW4XmUNFtmUrHLSY/tmxBcOLEn2fMV88KAR38h8TZD4qvGpqnIIaIf3Nip0+wv3km0KVlLs5rrWaZl142fZd/AvS0uY708nJuKS/Jizd8OcEstqOg0KJnfYQwRSJnZtoCWlDGgJ+WInk2Lr6zIr9FWdwNx5/uQvQwIDAQAB-----END PUBLIC KEY----- 用户界面：添加API密钥 密钥内容就是前面的公钥字符串 获取请求信息 复制json格式的字符串，找个代码美化在线工具。 请求信息 1234567891011121314151617181920212223&#123; \"compartmentId\": \"ocid1.tenancy.oc1..aaaaaaaavb77g5bgee2venclnxhonn3zjvb6xafodnx7uuya3edwq6fgd46a\", \"displayName\": \"instance-20191023-1024\", \"availabilityDomain\": \"shyQ:AP-SEOUL-1-AD-1\", \"sourceDetails\": &#123; \"sourceType\": \"image\", \"imageId\": \"ocid1.image.oc1.ap-seoul-1.aaaaaaaairwy3ids4ncccfatxvtwn57faqaajmb5oakqfcpkef665ek2zwpq\" &#125;, \"shape\": \"VM.Standard.E2.1.Micro\", \"createVnicDetails\": &#123; \"subnetId\": \"ocid1.subnet.oc1.ap-seoul-1.aaaaaaaazd53sfej5mq6myipe75cshsonckjsskuvgn5pq7wth2wlziyslcq\", \"assignPublicIp\": false &#125;, \"metadata\": &#123; \"ssh_authorized_keys\": \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQBo6+aohp7uY3H3YUuYMhgty+0m1Tw/48T/UEMZ98nEr/CzRvNByoN/s0guyhjqqi72D1oXaS2XFZLralWodCDWg7zeWKr/Nyc7udM5wYdVFqSeANlbSv4mS2CG1DyLIST8P3lpTXlWIcJWPUskGxjdMFVurGIIgEKKPpYMggK7eTwKoW/B+stLcKORjNYDGIh6Ny3R0JhR+i5Iyi7fb1N7Cei6nEiIDGvPE3soZpHcwE6AmxcYuOINhhDKwXQfFlLFngBx+Glyp4WA/7M08Ur+Fetk2Xk2DcY+GUnzHThQbgN4x3W48xQvx7IhPGEB+Z+3N2s9U6ZCzr+iyn0XauXx rsa-key-20190918\" &#125;, \"agentConfig\": &#123; \"isMonitoringDisabled\": false, \"isManagementDisabled\": false &#125;, \"definedTags\": &#123;&#125;, \"freeformTags\": &#123;&#125;&#125; 对照信息，填写参数 123456789oci compute instance launch--availability-domain shyQ:AP-SEOUL-1-AD-1--display-name instance-20191023-1024--image-id ocid1.image.oc1.ap-seoul-1.aaaaaaaairwy3ids4ncccfatxvtwn57faqaajmb5oakqfcpkef665ek2zwpq--subnet-id ocid1.subnet.oc1.ap-seoul-1.aaaaaaaazd53sfej5mq6myipe75cshsonckjsskuvgn5pq7wth2wlziyslcq--shape VM.Standard.E2.1.Micro--assign-public-ip true--metadata '&#123;\"ssh_authorized_keys\": \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQBo6+aohp7uY3H3YUuYMhgty+0m1Tw/48T/UEMZ98nEr/CzRvNByoN/s0guyhjqqi72D1oXaS2XFZLralWodCDWg7zeWKr/Nyc7udM5wYdVFqSeANlbSv4mS2CG1DyLIST8P3lpTXlWIcJWPUskGxjdMFVurGIIgEKKPpYMggK7eTwKoW/B+stLcKORjNYDGIh6Ny3R0JhR+i5Iyi7fb1N7Cei6nEiIDGvPE3soZpHcwE6AmxcYuOINhhDKwXQfFlLFngBx+Glyp4WA/7M08Ur+Fetk2Xk2DcY+GUnzHThQbgN4x3W48xQvx7IhPGEB+Z+3N2s9U6ZCzr+iyn0XauXx rsa-key-20190918\"&#125;'--compartment-id ocid1.tenancy.oc1..aaaaaaaavb77g5bgee2venclnxhonn3zjvb6xafodnx7uuya3edwq6fgd46a 去掉回车，变成一条命令 1oci compute instance launch --availability-domain shyQ:AP-SEOUL-1-AD-1 --display-name instance-20191024-1024 --image-id ocid1.image.oc1.ap-seoul-1.aaaaaaaairwy3ids4ncccfatxvtwn57faqaajmb5oakqfcpkef665ek2zwpq --subnet-id ocid1.subnet.oc1.ap-seoul-1.aaaaaaaazd53sfej5mq6myipe75cshsonckjsskuvgn5pq7wth2wlziyslcq --shape VM.Standard.E2.1.Micro --assign-public-ip true --metadata '&#123;\"ssh_authorized_keys\": \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQBo6+aohp7uY3H3YUuYMhgty+0m1Tw/48T/UEMZ98nEr/CzRvNByoN/s0guyhjqqi72D1oXaS2XFZLralWodCDWg7zeWKr/Nyc7udM5wYdVFqSeANlbSv4mS2CG1DyLIST8P3lpTXlWIcJWPUskGxjdMFVurGIIgEKKPpYMggK7eTwKoW/B+stLcKORjNYDGIh6Ny3R0JhR+i5Iyi7fb1N7Cei6nEiIDGvPE3soZpHcwE6AmxcYuOINhhDKwXQfFlLFngBx+Glyp4WA/7M08Ur+Fetk2Xk2DcY+GUnzHThQbgN4x3W48xQvx7IhPGEB+Z+3N2s9U6ZCzr+iyn0XauXx rsa-key-20190918\"&#125;' --compartment-id ocid1.tenancy.oc1..aaaaaaaavb77g5bgee2venclnxhonn3zjvb6xafodnx7uuya3edwq6fgd46a 复制运行这条命令，如果一会儿有输出的话那么就没问题了，接下来就可以定时执行命令创建云服务器了。 创建脚本确认oci-cli是否安装好 12[root@VM_0_12_centos ~]# find / -name oci_autocomplete.sh/root/lib/oracle-cli/lib/python2.7/site-packages/oci_cli/bin/oci_autocomplete.sh 新建文件 在/root下创建名为oci.sh的脚本文件 使用FinalShell新建文件 或者使用命令行 1touch /root/oci.sh 编辑文件 使用FinalShell编辑文件，双击oci.sh文件 12345678910111213141516vi /root/oci.sh## 键盘输入：i## 粘贴代码export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completionalias ic=\"ibmcloud\"export PATH=/root/bin:$PATH[[ -e \"/root/lib/oracle-cli/lib/python2.7/site-packages/oci_cli/bin/oci_autocomplete.sh\" ]] &amp;&amp; source \"/root/lib/oracle-cli/lib/python2.7/site-packages/oci_cli/bin/oci_autocomplete.sh\"#如果你们的bash环境下直接下面这句没报错，只用这一句也是ok的#上面这些主要是加入你们默认shell的内容，防止出现跟系统环境有关的错误，可改为source /root/.bashrc,这里.bashrc为你们的默认shelloci compute instance launch ......## 保存退出：Esc--&gt;:wq 定时执行脚本12345crontab -e## 键盘输入：i## 粘贴代码，代码设置为2分钟执行一次*/2 * * * * /bin/bash /root/oci.sh &gt;&gt; /root/oracle.log 2&gt;&amp;1## 保存退出：Esc--&gt;:wq 查看运行的定时命令 1234[root@VM_0_12_centos ~]# crontab -l*/2 * * * * /bin/bash /root/oci.sh &gt;&gt; /root/oracle.log 2&gt;&amp;1*/1 * * * * /usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;0 0 * * * /usr/local/qcloud/YunJing/YDCrontab.sh &gt; /dev/null 2&gt;&amp;1 &amp; 要实时显示刷的信息，可以使用下面命令查看 tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。 tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 1tail -F /root/oracle.log 显然直接查看oracle.log更直接 疑问与体验 参数中实例名字会不会创建两个一样的？ 体验：可以创建2个一样名字的实例，比如第一个是instance-1024，第二个会是instance-1024-3132，就是会自动给加参数区分，但是看着名字是一样的。 比如我第一个账号创建成功了，第二个账号怎么做？ 体验：重新修改oci配置，修改一下oci.sh文件的内容 甲骨文放货时间？ 体验：体会是北京时间早上7:30-8:00之间","categories":[{"name":"生活","slug":"生活","permalink":"https://ioufev.com/categories/生活/"}],"tags":[{"name":"计算机协议","slug":"计算机协议","permalink":"https://ioufev.com/tags/计算机协议/"}]},{"title":"Apache Shiro 10分钟教程","slug":"Apache Shiro 10分钟教程","date":"2019-12-23T11:43:18.568Z","updated":"2019-12-23T11:43:18.568Z","comments":true,"path":"2019/12/23/apache-shiro-10-fen-zhong-jiao-cheng/","link":"","permalink":"https://ioufev.com/2019/12/23/apache-shiro-10-fen-zhong-jiao-cheng/","excerpt":"Apache Shiro 10分钟教程","text":"Apache Shiro 10分钟教程 原文：https://shiro.apache.org/10-minute-tutorial.html 译文：https://www.cnblogs.com/strinkbug/p/6119887.html 介绍看完这个10分钟入门之后，你就知道如何在你的应用程序中引入和使用Shiro。以后你再在自己的应用程序中使用Shiro，也应该可以在10分钟内搞定。 概述什么是Apache Shiro？ Apache Shiro是一个功能强大且易于使用的Java安全框架，它为开发人员提供了一种直观，全面的身份验证，授权，加密和会话管理解决方案。 实际上，它可以管理应用程序安全性的所有方面，同时尽可能避免干扰。它建立在可靠的界面驱动设计和OO原则的基础上，可在您可以想象的任何地方实现自定义行为。但是，由于所有内容都具有合理的默认值，因此它可以像应用程序安全性一样“轻松”。至少这就是我们所追求的。 Apache Shiro可以做什么？ 很多 注意 Shiro可以在任何环境中运行，从最简单的命令行应用程序到最大的企业Web和集群应用程序，但是对于此QuickStart，我们将在简单的main方法中使用最简单的示例，以便您可以快速了解API。 下载确保已安装JDK 1.6+和Maven 3.0.3+。 从下载页面下载最新的“源代码分发” 。在此示例中，我们使用1.4.2版本。 解压源码包： 1$ unzip shiro-root-1.4.2-source-release.zip 进入quickstart目录： 1$ cd shiro-root-1.4.2/samples/quickstart 运行： 1$ mvn compile exec:java 该目标只会打印一些日志消息，让您知道发生了什么，然后退出。 在看本入门文档的过程中，可以打开源文件samples/quickstart/src/main/java/Quickstart.java，并且随意修改以测试你的想法。 QuickStart.java下面我们来分解说明Quickstart.java内的源码以便你可以更好的理解。 在任何环境下你都可以通过如下代码来获取当前登录的用户。 1Subject currentUser =SecurityUtils.getSubject(); 所谓Subject其实就是其他系统中的User，这里只是换一个说法，因为能够登录系统的不仅仅是人，还有其他系统。 如果是在一个独立的应用程序中调用getSubject()，我们会得到一个应用程序本地登录的用户信息，如果是一个web应用，则会得到一个和当前线程或者当前的session相关的用户。 不管怎么样，现在你得到了一个用户了，接下来可以做什么呢？ 如果你想要让某些数据在当前用户登录会话期间内一直有效，则可以像下面这么做： 12Session session = currentUser.getSession();session.setAttribute(\"someKey\",\"aValue\"); 我们可以把这个Session当成是HttpSession在Shiro中的特殊实现，他和HttpSession有着相似的接口，大家用起来不会陌生。但是他还有一个额外的好处：不依赖于HTTP的上下文环境。这样你就可以在一个非web应用（比如类似于本例子的命令行程序）中使用Session了。 如果是在一个Web应用程序中使用Session，则返回的Session是一种基于HttpSession的实现；而如果是在一个非web环境下使用，则默认使用的是Enterprise Session。不管怎么样，这意味着我们不用理会应用程序的部署环境，总是使用相同的API来操作session，带来一致的用户体验。现在，web应用和非web应用可以共享session数据了。 到目前为止，我们得到了一个Subject以及他的Session，现在我们用它们来做点有实际意义的事情怎么样，比如检查一下这个用户是否有权限做某件事情？ 我们可以为一个已知的用户做这些检查。我们上文中的Subject代表着当前用户，但是截至目前来说，谁是当前用户呢？在真正登录之前，Subject表示的是一个匿名用户。下面让我们来看看登录怎么做。 12345678910if ( !currentUser.isAuthenticated() ) &#123; //collect user principals and credentials in a gui specific manner //such as username/password html form, X509 certificate, OpenID, etc. //We'll use the username/password example here since it is the most common. //(do you know what movie this is from? ;) UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); //this is all you have to do to support 'remember me' (no config - built in!): token.setRememberMe(true); currentUser.login(token);&#125; 就这样，简单的不能再简单了。 但是如果登录失败了怎么办？你可以通过捕获异常来准确了解到底发生了什么错误，然后针对性的做一些处理。 1234567891011121314try &#123; currentUser.login( token ); //if no exception, that's it, we're done!&#125; catch ( UnknownAccountException uae ) &#123; //username wasn't in the system, show them an error message?&#125; catch ( IncorrectCredentialsException ice ) &#123; //password didn't match, try again?&#125; catch ( LockedAccountException lae ) &#123; //account for that username is locked - can't login. Show them a message?&#125; ... more types exceptions to check if you want ...&#125; catch ( AuthenticationException ae ) &#123; //unexpected condition - error?&#125; 你可以检测很多种不同类型的异常，或者你也可以抛出自己的异常。可以 AuthenticationException JavaDoc去了解更多。 好了，到目前为止，我们有了一个已经登录的用户，然后我们还可以做些什么呢？比如我们可以打印一些信息来说明我们是谁： 12//print their identifying principal (in this case, a username): log.info( \"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\" ); 我们也可以测试一下看当前用户是否拥有某个角色。 12345if ( currentUser.hasRole( \"schwartz\" ) ) &#123; log.info(\"May the Schwartz be with you!\" );&#125; else &#123; log.info( \"Hello, mere mortal.\" );&#125; 又或者我们可以看看他是否有权限去执行针对某种数据的某种操作。 12345if ( currentUser.isPermitted( \"lightsaber:weild\" ) ) &#123; log.info(\"You may use a lightsaber ring. Use it wisely.\");&#125; else &#123; log.info(\"Sorry, lightsaber rings are for schwartz masters only.\");&#125; 我们还可以做一个实例级别的权限检查——看看该用户是否有权限访问某种类型数据的某个具体实例。 123456if ( currentUser.isPermitted( \"winnebago:drive:eagle5\" ) ) &#123; log.info(\"You are permitted to 'drive' the 'winnebago' with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\");&#125; else &#123; log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\");&#125; 真是小菜一碟，不是吗？ 最后，如果该用户已经做完了所有的事情，他就可以退出登录了。 1currentUser.logout(); //removes all identifying information and invalidates their session too. 好了，如果我们要在应用程序中使用Apache Shiro，了解以上这些API也就差不都了。虽然在这些优雅的代码下面隐藏了一些复杂的实现。但是对于使用者来说，真的这样就够了。 不过你可能会问你自己：“在用户登录的时候，谁来负责获取用户相关的数据呢（比如用户名、密码、角色、权限等），并且在运行时谁来真正的执行这些安全检查？”，我只能说，是你是你都是你，你要实现一种自Shiro中曾作Realm的接口，并且把它继承到Shiro的配置中。 但是，如何配置Realm主要和你的运行时环境有关。比如，你可能运行的是一个独立的应用、或者而是一个web应用、或者是一个依赖于spring或者JEE容器的的应用，或者是以上几种类型的组合。对于一个10分钟入门来说，以上的这些配置都太复杂了，本节的主要目的是带你熟悉一下Shiro的API以及相关的一些概念。 在你继续了解其他细节之前，你可能更想先去阅读一下用户验证向导和用户授权向导，然后在继续阅读其他的文档，特别是参考手册","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://ioufev.com/tags/shiro/"}]},{"title":"Apache Shiro 架构","slug":"Apache Shiro 架构","date":"2019-12-23T11:43:18.568Z","updated":"2019-12-23T11:43:18.568Z","comments":true,"path":"2019/12/23/apache-shiro-jia-gou/","link":"","permalink":"https://ioufev.com/2019/12/23/apache-shiro-jia-gou/","excerpt":"Apache Shiro 架构","text":"Apache Shiro 架构 原文：https://shiro.apache.org/architecture.html 译文：https://www.cnblogs.com/strinkbug/p/6139393.html Shiro的设计目标就是让应用程序的安全管理更简单、更直观。 软件系统一般是基于用户故事来做设计。也就是我们会基于一个客户如何与这个软件系统交互来设计用户界面和服务接口。比如，你可能会说：“如果用户登录了我们的系统，我就给他们显示一个按钮，点击之后可以查看他自己的账户信息。如果没有登录，我就给他显示一个注册按钮。” 上述应用程序在很大程度上是为了满足用户的需求而编写的，即便这个“用户”不是人，而是一个其他的软件系统。你仍然是按照谁当前正在与你的系统交互的逻辑来编写你的逻辑代码。 Shiro的设计已经考虑到以上这些用户安全的概念。 总览在最顶层，Shiro的架构有3个主要概念：Subject、SecurityManager和Realms。下图展示了这几个组件之间的交互，下面我们会逐一介绍这些概念： Subject，正如我们在教程中所说，Subject其实代表的就是当前正在执行操作的用户，只不过因为“User”一般指代人，但是一个“Subject”可以是人，也可以是任何的第三方系统，服务账号等任何其他正在和当前系统交互的第三方软件系统。 所有的Subject实例都被绑定到一个SecurityManager，如果你和一个Subject交互，所有的交互动作都会被转换成Subject与SecurityManager的交互。 SecurityManager。SecurityManager是Shiro的核心，他主要用于协调Shiro内部各种安全组件，不过我们一般不用太关心SecurityManager，对于应用程序开发者来说，主要还是使用Subject的API来处理各种安全验证逻辑。 Realm，这是用于连接Shiro和客户系统的用户数据的桥梁。一旦Shiro真正需要访问各种安全相关的数据（比如使用用户账户来做用户身份验证以及权限验证）时，他总是通过调用系统配置的各种Realm来读取数据。 正因为如此，Realm往往被看做是安全领域的DAO，他封装了数据源连接相关的细节，将数据以Shiro需要的格式提供给Shiro。当我们配置Shiro的时候，我们至少需要配置一个Realm来提供用户验证和权限控制方面的数据。我们可能会给SecurityManager配置多个Realm，但是不管怎样，我们至少需要配置一个。 Shiro提供了几种开箱即用的Realm来访问安全数据源，比如LDAP、关系数据库、基于ini的安全配置文件等等，如果默认提供的这几种Realm无法满足你的需求，那么你也可以编写自己的定制化的Realm插件。 和其他内部组件一样，SecurityManager决定了在Shiro中如何使用Realm来读取身份和权限方面的数据，然后组装成Subject实例。 详细架构下图展示了Shiro的核心组件，并概述了每个组件的功能。 Subject，(org.apache.shiro.subject.Subject)，当前与软件进行交互的实体（用户，第三方服务，计划任务等）的特定于安全性的“视图”。； SecurityManager， (org.apache.shiro.mgt.SecurityManager)，如上所述；这SecurityManager是Shiro体系结构的核心。它主要是一个“伞”对象，用于协调其托管组件以确保它们能够顺利协同工作。它还管理Shiro对每个应用程序用户的视图，因此它知道如何对每个用户执行安全性操作。 Authenticator（用户认证管理器）， (org.apache.shiro.authc.Authenticator)这个组件主要用于处理用户登录逻辑，他通过调用Realm的接口来判断当前登录的用户的身份。 用户认证策略，(org.apache.shiro.authc.pam.AuthenticationStrategy) 如果系统配置了多个Realm，则需要使用AuthenticationStrategy 来协调这些Realm以便决定一个用户登录的认证是成功还是失败。（比如，如果一个Realm验证成功了，但是其他的都失败了，那么这次认证算是成功了吗？还是说必须所有的Realm都认为成功了才算成功？或者是第一个成功就算成功？可见，策略还是蛮复杂的）； Authorizer（权限管理器）(org.apache.shiro.authz.Authorizer) 这个组件主要是用来做用户的访问控制。通俗来说就是决定用户能做什么、不能做什么。和Authenticator类似，Authorizer也知道怎么协调多个Realm数据源的数据，他有自己的一套策略。 SessionManager（会话管理器） (org.apache.shiro.session.mgt.SessionManager) SessionManager知道如何创建会话、管理用户回话的声明周期以便在所有运行环境下都可以给用户提供一个健壮的回话管理体验。Shiro在任何运行环境下都可以在本地管理用户会话（即便没有Web或者EJB容器也可以）——这在安全管理的框架中算是独门绝技了。当然，如果当前环境中有会话管理机制（比如Servlet容器），则Shiro默认会使用该环境的会话管理机制。而如果像控制台程序这种独立的应用程序，本身没有会话管理机制，此时Shiro就会使用内部的会话管理器来给应用的开发提供一直的编程体验。SessionDAO允许用户使用任何类型的数据源来存储Session数据。 SessionDAO，(org.apache.shiro.session.mgt.eis.SessionDAO)用于代替SessionManager执行Session相关的增删改查。这个接口允许我们将任意种类的数据存储方式引入到Session管理的基础框架中。 CacheManager(org.apache.shiro.cache.CacheManager)CacheManager用于创建和维护一些在其他的Shiro组件中用到的Cache实例，维护这些Cache实例的生命周期。缓存用于存储那些从后端获取到的用户验证与权限控制方面的数据以提高性能，缓存是一等公民，在获取数据时，总是先从缓存中查找，如果没有再调用后端接口从其他数据源获取。Shiro允许用户使用其他更加现代的、企业级的数据源来替代内部的默认实现，以提供更高的性能和更好的用户体验。 Cryptography ，加密技术，(org.apache.shiro.crypto.*)对于一个企业级的安全框架来说，加密算是其固有的一种特性。Shiro的crypto包中包含了一系列的易于理解和使用的加密、哈希（aka摘要）辅助类。这个包内的所有类都是经过精心设计，相比于java本身提供的那一套反人类的加密组件，Shiro提供的这套加密组件简直不要好用太多。 Realm，(org.apache.shiro.realm.Realm)就如上文所提到的，Realm是连接Shiro和你的安全数据的桥梁。任何时候当Shiro需要执行登录或者访问控制的时候，都需要调用已经配置的Realm的接口去获取数据。一个应用程序可以配置一个或者多个Realm（通常来说一种数据源配置一个）。 SecurityManagerShiro对外主要提供了以Subject为核心的一些列API，各种用户验证与权限控制的接口都是围绕着Subject来设计的，所以一般的用户不太会需要直接和SecurityManager类打交道。即便如此，如果我们能够了解一些SecurityManager相关的工作原理，对于我们更好的用好Shiro还是大有裨益的。 设计如上文所述，应用程序的SecurityManager执行安全相关的操作并管理该应用的所有用户的状态。在Shiro的SecurityManager的默认实现中，这些操作和状态包括： 用户认证； 权限控制； 回话管理； 缓存管理； Realm的协调调度； 事件传播； “Remember Me”服务； 创建Subject； 退出登录； 如果要在一个类内部实现所有这些功能，那将是相当复杂。而如果我们还进一步要求所有这些特性都要足够灵活、可定制，那可如何是好？ 为了提供更加灵活的可配置特性、可插拔的特性，Shiro的实现完全是模块化的，SecurityManager本身几乎不做什么事情，他只是一个轻量级的“容器”组件，他把所有的功能都转发给相关的子组件去完成，这种包装器的设计模式见上文 详细架构 中的框图。 SecurityManager也兼容JavaBeans，这样我们就可以通过JavaBean的标准的get/set方法来给SecurityManager诸如一些定制化的组件。 易于配置： 因为与JavaBean兼容，所以我们可以使用任何与JavaBean兼容的机制来给SecurityManager注入一些定制化的组件，比如Spring、Guice、Jboss等等。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://ioufev.com/tags/shiro/"}]},{"title":"Apache Shiro 简介","slug":"Apache Shiro 简介","date":"2019-12-23T11:43:18.568Z","updated":"2019-12-23T11:43:18.568Z","comments":true,"path":"2019/12/23/apache-shiro-jian-jie/","link":"","permalink":"https://ioufev.com/2019/12/23/apache-shiro-jian-jie/","excerpt":"Apache Shiro 简介","text":"Apache Shiro 简介 原文：https://shiro.apache.org/introduction.html 译文：https://www.cnblogs.com/strinkbug/p/6117353.html 什么是ShiroApache Shiro是一个强大、灵活、开源的安全框架，它支持用户认证、权限控制、企业会话管理以及加密等。 Apache Shiro的第一个也是最重要的一个目标就是易于使用和理解。对应用程序做安全管理常常很复杂，甚至很痛苦，但是实际上完全可以避免。一个好的安全安全管理框架应该能够将复杂度隐藏在框架内部，对外提供简洁、直观的API，以便用户可以很简单的给应用添加安全控制。 下面是Apache Shiro能够提供给我们的一些特性： 做用户身份认证； 做访问权限控制，比如： 这个用户是否被赋予了某个角色； 这个用户是否有权限做某件事情； 可以在任何环境下使用用户会话管理，即便没有web或者ejb容器也可以； 可以整合多种类型的用户权限数据（比如关系数据库、LDAP等）到一个用户视图界面； 支持单点登录（Single Sign On SSO）； 支持 记住秘密 服务。 Shiro尽力为各种应用程序的环境来达成以上的目标——从简单的命令行程序到大型企业应用，不要求支持任何第三方的框架、容器或者应用服务器。当然，Shiro会尽力与这些环境集成，但是Shiro的运行绝对不会依赖于这些环境。 Apache Shiro的特性Shiro的特性很多，下图展示了Shiro的架构，从中我们可以了解到Shiro聚焦在哪里，并且我们这个系列的文档也是按照类似的结构来组织。 Shiro聚焦与应用程序安全领域的四大基石：认证、授权、会话管理和保密。 认证，也叫作登录，用于验证用户是不是他自己所说的那个人； 授权，也就是访问控制，比如用于决定“谁”是否有权限访问“什么”； 会话管理，管理用户相关的会话，即使在非web和ejb的环境下也支持； 保密，使用特性加密算法来保证用户数据的安全性，同时还要保证用起来够简单； 同时Shiro还提供了其他特性来在不同的应用程序环境下使用强化以上的四大基石： Web支持：Shiro的web相关的API简化了web应用安全控制； 缓存，在Shiro中，缓存是一等公民，用于保证用户认证和权限控制的性能； 测试，支持可测试性，以便用户可以方便的对安全相关代码编写单元测试和集成测试； 记住密码，可以跨会话的记住用户的身份信息，以便只有在一些强制性的场合才需要登录。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://ioufev.com/tags/shiro/"}]},{"title":"Apache Shiro 术语","slug":"Apache Shiro 术语","date":"2019-12-23T11:43:18.568Z","updated":"2019-12-23T11:43:18.568Z","comments":true,"path":"2019/12/23/apache-shiro-zhu-yu/","link":"","permalink":"https://ioufev.com/2019/12/23/apache-shiro-zhu-yu/","excerpt":"Apache Shiro 术语","text":"Apache Shiro 术语 原文：https://shiro.apache.org/terminology.html 译文：https://www.cnblogs.com/strinkbug/p/6117368.html 做任何事情，首先要双方就一些概念的理解达成一致，这样大家就有共同语言，后续的沟通效率会高一些。 Authentication，认证，也就是验证用户的身份，就是确定你是不是你，比如通过用户名、密码的方式验证，或者某些第三方认证，比如微信认证。 Authorization，授权，也叫访问控制，也就是看你是否有权限做什么事情，比如是否有权限看某个文件，或者是否有权限做后台管理； Cipher，加密方式，这里主要有几种常用的加密方式，比如分组密码（Block Ciphers）、流密码（Stream Ciphers）、对称加密（Symmetric Ciphers）、非对称加密（Asymmetric Ciphers） Credential，证书，比如密码、指纹或者网银的Key都算是证书的一种。系统通过将用户提供的证书和系统存储的证书比较，如果一致就认为用户的身份是对的； Hash，哈希，一种单相的数据加密算法； Persmission，权限，用于描述系统的某项基础功能，比如 “打开一个文件”，“查看’/user/list/’页面”，“打印文档”，这些都算是一种权限； Principal，身份，就是一种用于标识用户身份的一种属性，比如邮箱、电话号码、用户名、微信号等； Realm，这是一个用于访问应用程序的用户、角色、权限的组件，可以把它看做是Shiro的DAO(Data Access Object)，用于把各种存储介质（比如关系数据库、LDAP、文件）内的用户权限数据转换为Shiro能够理解的格式。 Role，角色，在Shiro中，角色就是权限的组合； Session，会话，也就是用户登录之后的上下文，在用户登出之前可以不用传递用户名、密码就可以做各种操作； Subject，起始就是user，但是在Shiro中把它叫做Subject，因为和我们系统交互的不一定是人，也可能是其他的系统。 authentication [ɔ.θentɪ’keɪʃ(ə)n] 身份验证 authorization [.ɔθərɪ’zeɪʃ(ə)n] 授权 cipher [‘saɪfə(r)] 密码；密文；加密算法 credential [krə’denʃl] 凭证；凭据；证书；文凭 principal [‘prɪnsəp(ə)l] 本金；主角；最重要的；校长；负责人；主体；身份 realm [relm] 范围；区域 session [ˈseʃ(ə)n] 会话","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://ioufev.com/tags/shiro/"}]},{"title":"Apache Shiro 配置","slug":"Apache Shiro 配置","date":"2019-12-23T11:43:18.568Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/12/23/apache-shiro-pei-zhi/","link":"","permalink":"https://ioufev.com/2019/12/23/apache-shiro-pei-zhi/","excerpt":"Apache Shiro 配置","text":"Apache Shiro 配置 原文：https://shiro.apache.org/configuration.html 译文：https://www.cnblogs.com/strinkbug/p/6139393.html Shiro设计的初衷就是可以运行于任何环境：无论是简单的命令行应用程序还是复杂的企业集群应用。由于运行环境的多样性，所以有多种配置机制可用于配置，本节我们将介绍Shiro内核支持的这几种配置机制。 许多配置选项 Shiro的SecurityManager实现和所有支持组件都与JavaBeans兼容。这使Shiro可以使用几乎任何配置格式进行配置，例如常规Java，XML（Spring，JBoss，Guice等），YAML，JSON，Groovy Builder标记等。 程序配置最简单的创建并且使用SecurityManager的方式就是直接在代码中创建·org.apache.shiro.mgt.DefaultSecurityManager·类实例，比如： 12345Realm realm = //instantiate or acquire a Realm instance. We'll discuss Realms later.SecurityManager securityManager = new DefaultSecurityManager(realm);//Make the SecurityManager instance available to the entire application via static memory: SecurityUtils.setSecurityManager(securityManager); 只需区区三行代码，我们就已经为任何类型的应用程序配置好了一个全功能的Shiro运行环境，你看，多简单。 SecurityManager对象图谱：就像我们在架构一节中介绍的，SecurityManager的实现是模块化的，而且可以兼容JavaBean，所以你可以通过setter和getter方法来配置SecurityManager及其内部组件。 比如如果你想把一个自定义的SessionDAO配置为SecurityManager的Session管理器，你可以直接调用SessionManager的setSessionDAO方法。 12345678...DefaultSecurityManager securityManager = new DefaultSecurityManager(realm);SessionDAO sessionDAO = new CustomSessionDAO();((DefaultSessionManager)securityManager.getSessionManager()).setSessionDAO(sessionDAO);... 你可以通过这种调用setter方法的方式来设置SecurityManager的任何内置组件。但是对于现实的应用程序来说，这不是一种理想的配置方式。主要有以下几点原因： 这种直接编码的方式要求我们知道这个具体的实现类在哪，并且要自己去创建他。而我们一般建议是依赖于抽象而不是具体，所以最好不要让我知道他具体的实现在哪里。 由于java的类型安全特性，当我们通过getter方法获取到某个类的具体实现之后，我们将不得不把他们强制类型转换为具体的类型，如此多的强制类型转换太丑了，不是一种好的编程实践。 如果我们通过SecurityUtils.setSecurityManager方法为当前的应用设置一个虚拟机范围内的静态SecurityManager对象，在大多数应用中都是ok的。但是如果我们要在一个虚拟机上运行多个使用Shiro的应用程序时，就可能会出乱子了。所以如果能够为每个应用程序创建一个的单例就更好了； 每次你要修改一下Shiro的配置都不得不重新编译程序； 虽然有以上提到的种种缺点，但是如果你要在一个内存受限的环境（比如智能手机）中使用Shiro，使用基于java代码的配置还是不错的选择。而如果内存不太受限的话，使用推荐使用基于文本的配置，因为他对用户更友好，具有更好的可读性。 INI配置为了让这个文本配置方案能够在所有的开发环境中使用，并且尽可能的减少对于第三方工具的依赖，我们选择了INI格式来配置SecurityManager及其相关组件。INI具有易读、易配置的特性，可以适用于绝大多数的应用。 从INI文件中创建一个SecurityManager以下将提供两种基于INI配置文件创建SecurityManager的方法。 从INI资源文件中创建SecurityManager 我们可以通过一个INI资源的路径来创建一个SecurityManager，资源可以通过文件系统、classpath、或者url中获取，不同的获取方式需要在资源路径前加不同的前缀，分别是file:, classpath 或者 url:，下面这个例子我们使用一个工厂类从根classpath中找到shiro.ini文件，然后实例化了一个SecurityManager对象。 12345678910import org.apache.shiro.SecurityUtils;import org.apache.shiro.util.Factory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.config.IniSecurityManagerFactory;...Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager); 从INI类实例中创建SecurityManager 如果有需要，我们也可以通过org.apache.shiro.config.Ini类来做INI配置，这个Ini类的API和java.util.Properties类比较像，只是在接口中需要传入Section的名称。 例如： 1234567891011121314import org.apache.shiro.SecurityUtils;import org.apache.shiro.util.Factory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.config.Ini;import org.apache.shiro.config.IniSecurityManagerFactory;...Ini ini = new Ini();//populate the Ini instance as necessary...Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(ini);SecurityManager securityManager = factory.getInstance();SecurityUtils.setSecurityManager(securityManager); 以上我们已经知道如何通过INI配置来实例化SecurityManager对象，下面就让我们来看看一个真实的Shiro的配置文件到底长什么样。 INI Secions所谓的INI文件其实就是按Section分隔的键值对的集合，不同的Section名称不同，每个Section内的键名称要有唯一性。每个Section可以看做就是一个Properties。 注释行可以井号（#） 开头，也可以 分号（;）开头。 下面就是一个Shiro能够解析的INI文件的例子，他的这些Section名称是Shiro所支持的。 1234567891011121314151617181920212223# =======================# Shiro INI configuration# =======================[main]# Objects and their properties are defined here,# Such as the securityManager, Realms and anything# else needed to build the SecurityManager[users]# The 'users' section is for simple deployments# when you only need a small number of statically-defined# set of User accounts.[roles]# The 'roles' section is for simple deployments# when you only need a small number of statically-defined# roles.[urls]# The 'urls' section is used for url-based security# in web applications. We'll discuss this section in the# Web documentation [main][main]段主要用于配置SecurityManager及其他的依赖项，比如Realms。要使用INI这种简单键值对文件格式来配置SecurityManager对象及其依赖项这种层级关系感觉难度有点大，只要稍微加上一些约定，你会发现INI文件能做的远比我们想象的要多，我们把这种基于INI的配置叫做“穷人”的依赖注入。虽然没有Spring/JBoss之类的高富帅那么强大，但是已经足够满足Shiro的配置要求了。下面是一个[main]段的配置例子，我们会在下文详细解释，不过我估计在解释之前，你也能猜个八九不离十了。 12345678910[main]sha256Matcher = org.apache.shiro.authc.credential.Sha256CredentialsMatchermyRealm = com.company.security.shiro.DatabaseRealmmyRealm.connectionTimeout = 30000myRealm.username = jsmithmyRealm.password = secretmyRealm.credentialsMatcher = $sha256MatchersecurityManager.sessionManager.globalSessionTimeout = 1800000 定义一个对象 看下面这段[main]配置片段。 123[main]myRealm = com.company.shiro.realm.MyRealm... 这段配置创建了类 com.company.shiro.realm.MyRealm的一个实例，命名为myRealm。如果这个类实现了org.apache.shiro.util.Nameable接口，则程序会使用参数”myRealm”来调用Nameable.setName接口。 设置对象属性 基本类型 基本类型属性可以像下面这样直接赋值 1234...myRealm.connectionTimeout = 30000myRealm.username = jsmith... 这段配置翻译成Java代码后是这样的： 1234...myRealm.setConnectionTimeout(30000);myRealm.setUsername(\"jsmith\");... 这是如何做到的呢？ 这里假定所有的对象都是和Java Bean兼容的POJO对象。· 在这种约定的前提下，当给对象设置属性时，Shiro会将所有的脏活、累活都交给Apache Common BeanUtils来干，虽然我们在INI文件内配置的是文本，但是BeanUtils知道如何将一个字符串的值转换为基本类型，并且调用该对象的对应的setter方法来给该POJO设置属性。 引用类型 如果要设置是引用类型怎么办？你可以用一个美元符号（$）来引用前文中定义的对象，像下面这样，就这么简单。 12345...sha256Matcher = org.apache.shiro.authc.credential.Sha256CredentialsMatcher...myRealm.credentialsMatcher = $sha256Matcher... 这只是找到名称为sha256Matcher定义的对象，然后使用BeanUtils在myRealm实例上设置该对象（通过调用myRealm.setCredentialsMatcher(sha256Matcher)方法）。 嵌套属性 你可以像下面这样引用嵌套属性，给属性赋值，不管有多少个层级，都可以这么用。 使用INI线的等号左侧的虚线表示法，可以遍历对象图以到达要设置的最终对象/属性。例如，此配置行： 123...securityManager.sessionManager.globalSessionTimeout = 1800000... BeanUtils会把他翻译成下面这样的代码： 1securityManager.getSessionManager().setGlobalSessionTimeout(1800000); 这种嵌套的层级可以要多深有多深，比如：object.property1.property2.....propertyN.value=blah BeanUtil支持的属性设置 只要是BeanUtil支持的属性设置方式你都可以在Shiro配置文件的[main] Section中配置。包括对于set/list/map属性的设置。详情可以参考 Apache Commons BeanUtils Website官方文档。 字节数组 因为在文本文件中无法直接表示二进制树，所以必须使用一种可以使用文本编码的方式来表示二进制数组，有两种选择，一种是：BASE64，一种是十六进制字符串。默认使用BASE64编码，因为表示相同长度的二进制，BASE64需要的字节更少。这显然更合适文本配置。 12345# The 'cipherKey' attribute is a byte array. By default, text values# for all byte array properties are expected to be Base64 encoded:securityManager.rememberMeManager.cipherKey = kPH+bIxk5D2deZiIxcaaaA==... 十六进制的文本当然也是可以的，你要记得在文本的前面加上0x。 1securityManager.rememberMeManager.cipherKey = 0x3707344A4093822299F31D008 集合属性 我们可以像设置其他属性一样去设置list、set、map类型的属性，不管是直接的属性还是嵌套属性。对于list和set，我们可以直接使用逗号分隔的值（或者引用）来设置，例如： 12345sessionListener1 = com.company.my.SessionListenerImplementation...sessionListener2 = com.company.my.other.SessionListenerImplementation...securityManager.sessionManager.sessionListeners = $sessionListener1, $sessionListener2 对于map，你可以指定一系列都好分隔的键值对。键值对内部使用 冒号来作为键和值的分隔符，例如： 123456object1 = com.company.some.Classobject2 = com.company.another.Class...anObject = some.class.with.a.Map.propertyanObject.mapProperty = key1:$object1, key2:$object2 你还可以直接使用对象来作为key，如下： 1anObject.map = $objectKey1:$objectValue1, $objectKey2:$objectValue2 注意事项 订单事项 上面的INI格式和约定非常方便且易于理解，但是不如其他基于文本/ XML的配置机制强大。使用上述机制时，最重要的要了解的是订单事项！ 顺序问题 在INI文件中配置的顺序决定了他们翻译成Java代码之后的顺序，这块要小心。 重写实例 后定义的同名对象会覆盖之前定义的对象，如下第二个myRealm会覆盖掉第一个myRealm的定义，所以最终myRealm是com.company.security.DatabaseRealm的对象实例，而前一个定义的realm将永远不会被引用了。（自然也就被垃圾回收了）。 12345...myRealm = com.company.security.MyRealm...myRealm = com.company.security.DatabaseRealm... 默认的SecurityManager 你可能已经注意到，在上文的配置中，我们并没有创建SecurityManager对象就直接去设置他的嵌套属性了。 1234myRealm = ...securityManager.sessionManager.globalSessionTimeout = 1800000... SecurityManager是特例，系统已经自动为你创建好了一个SecurityManager对象，你就只管用就好了。当然，如果你说我一定要使用字节实现的一个SecurityManager，那也不是不行，直接像下面这么写就可以了，就像 重写实例 章节中说的，这样就会覆盖掉系统自动创建的SecurityManager对象了。 123...securityManager = com.company.security.shiro.MyCustomSecurityManager... 当然，这种情况很少发生。因为Shiro默认提供的SecurityManager具有很好的定制性，你几乎可以为配置任何属性。所以如果你发现自己要写一个自定义的SecurityManager的时候，不妨先问问自己：这真的有必要吗？ [users][users]Setion允许你定义一组用户账号。在那些只需要很少的用户账号，或者是那些不需要在运行时动态创建用户账号的运行环境下，这个功能很实用。你可以像下面这么写。 1234[users]admin = secretlonestarr = vespa, goodguy, schwartzdarkhelmet = ludicrousspeed, badguy, schwartz 自动生成的IniRealm 一旦Shiro发现INI文件的[users], [roles]章节不为空，他就会自动创建一个org.apache.shiro.realm.text.IniRealm类的实例并命名为iniRealm，所以你可以在[main]章节中像配置其他对象一样给iniRealm配置属性。 行格式 在[users]的每一行将定义成如下格式 username=password, roleName1, roleName2, …, roleNameN 左边的key是用户名； 右边是逗号分隔的密码和角色，其中第一个而是密码，后续的是角色名，角色可以有多个； 角色是可选的； 密码加密 如果你不想让密码直接用明文显示，也可以使用任何你喜欢的加密算法（MD5,Sha1,Sha256, 等等）来对密码做加密，然后把加密之后的文本复制到INI文件中。加密之后的密码默认应该以十六进制的文本，当然也可以是BASE64的，具体看下问的说明。 简单安全的密码 对密码做加密的最佳实践是使用Shiro提供的 Command Line Hasher工具，他会对密码或者其他你想要加密的文本做哈希，这个工具对于要放在Shiro的INI配置文件的[users]中显示的密码最为实用。 如果你对密码做了加密，那么你就要告诉Shiro你对密码做了加密，不然他就不认识了。你可以在[main]端中配置Shiro隐式生成的iniRealm类，把你加密密密时使用的加密算法指定给credentialsMatcher属性即可。 12345678910[main]...sha256Matcher = org.apache.shiro.authc.credential.Sha256CredentialsMatcher...iniRealm.credentialsMatcher = $sha256Matcher...[users]# user1 = sha256-hashed-hex-encoded password, role1, role2, ...user1 = 2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b, role1, role2, ... 和其他属性一样，你可以给CredentialMatcher配置任何值来体现你的哈希策略，比如指定一个盐值，或者是哈希迭代的次数。要想更好的了解哈希策略，你可以查看org.apache.shiro.authc.credential.HashedCredentialsMatcher的API文档。 比如，如果用户的密码是BASE64编码，而不是默认的16进制，则应该像下面这么配置。 1234[main]...# true = hex, false = base64:sha256Matcher.storedCredentialsHexEncoded = false [roles]这个session用于定义角色与权限的对照关系，同样的，这种配置方式对于那些只有少数几种角色，并且不需要在运行时动态创建角色的应用程序特别实用。 12345678[roles]# 'admin' role has all permissions, indicated by the wildcard '*'admin = *# The 'schwartz' role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with# license plate 'eagle5' (instance specific id)goodguy = winnebago:drive:eagle5 行格式 在[roles]中的每一行都必须定义为角色与权限的键值对关系，格式如下： rolename=permissionDefinition1,permissionDefinition2,…, permissionDefinitionN 此处permissionDefinition 可以是任意文本，不过一般我们会建议使用和org.apache.shiro.authz.permission.WildcardPermission格式兼容的文本格式，这种格式简单而又灵活。可以查看权限（ Permissions）章节来了解更多关于这种权限格式的信息。 [urls]这个Section的描述将放在 Web 章节。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"https://ioufev.com/tags/shiro/"}]},{"title":"Logback日志","slug":"Logback日志","date":"2019-12-13T02:07:33.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/12/13/logback-ri-zhi/","link":"","permalink":"https://ioufev.com/2019/12/13/logback-ri-zhi/","excerpt":"Logback日志，输出到文件以及实时输出到web页面","text":"Logback日志，输出到文件以及实时输出到web页面 转载：SpringBoot系列——Logback日志，输出到文件以及实时输出到web页面 前言SpringBoot对所有内部日志使用通用日志记录，但保留底层日志实现。为Java Util Logging、Log4J2和Logback提供了默认配置。在不同的情况下，日志记录器都预先配置为使用控制台输出，同时还提供可选的文件输出。默认情况下，SpringBoot使用Logback进行日志记录。 日志级别有（从高到低）：FATAL（致命），ERROR（错误），WARN（警告），INFO（信息），DEBUG（调试），TRACE（跟踪）或者 OFF（关闭），默认的日志配置在消息写入时将消息回显到控制台。默认情况下，将记录错误级别、警告级别和信息级别的消息。 PS：Logback does not have a FATAL level. It is mapped to ERROR Logback没有FATAL致命级别。它被映射到ERROR错误级别 详情请戳官方文档：https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging 本文主要记录Logback日志输出到文件以及实时输出到web页面 输出到文件我们创建SpringBoot项目时，spring-boot-starter已经包含了spring-boot-starter-logging，不需要再进行引入依赖 标准日志格式123452014-03-05 10:57:51.112 INFO 45469 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/7.0.522014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1358 ms2014-03-05 10:57:51.698 INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/]2014-03-05 10:57:51.702 INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*] Date and Time: Millisecond precision and easily sortable. 日期和时间:毫秒精度，易于排序。 Log Level: ERROR, WARN, INFO, DEBUG, or TRACE. 日志级别:错误、警告、信息、调试或跟踪。 Process ID. 进程ID。 A — separator to distinguish the start of actual log messages. 分隔符，用于区分实际日志消息的开始。 Thread name: Enclosed in square brackets (may be truncated for console output). 线程名称:括在方括号中(可能会被截断以用于控制台输出)。 Logger name: This is usually the source class name (often abbreviated). 日志程序名称:这通常是源类名称(通常缩写)。 The log message. 日志消息。 如何打印日志？方法1 123456789101112131415161718192021222324252627282930313233343536/** * 配置内部类 */ @Controller @Configuration class Config &#123; /** * 获取日志对象，构造函数传入当前类，查找日志方便定位 */ private final Logger log = LoggerFactory.getLogger(this.getClass()); @Value(\"$&#123;user.home&#125;\") private String userName; /** * 端口 */ @Value(\"$&#123;server.port&#125;\") private String port;/** * 启动成功 */ @Bean public ApplicationRunner applicationRunner() &#123; return applicationArguments -&gt; &#123; try &#123; InetAddress ia = InetAddress.getLocalHost(); //获取本机内网IP log.info(\"启动成功：\" + \"http://\" + ia.getHostAddress() + \":\" + port + \"/\"); log.info(\"$&#123;user.home&#125; ：\" + userName); &#125; catch (UnknownHostException ex) &#123; ex.printStackTrace(); &#125; &#125;; &#125; &#125; 方法2 使用lombok的@Slf4j，帮我们创建Logger对象，效果与方法1一样 1234567891011121314151617181920212223242526272829303132/** * 配置内部类 */ @Slf4j @Controller @Configuration class Config &#123; @Value(\"$&#123;user.home&#125;\") private String userName; /** * 端口 */ @Value(\"$&#123;server.port&#125;\") private String port;/** * 启动成功 */ @Bean public ApplicationRunner applicationRunner() &#123; return applicationArguments -&gt; &#123; try &#123; InetAddress ia = InetAddress.getLocalHost(); //获取本机内网IP log.info(\"启动成功：\" + \"http://\" + ia.getHostAddress() + \":\" + port + \"/\"); log.info(\"$&#123;user.home&#125; ：\" + userName); &#125; catch (UnknownHostException ex) &#123; ex.printStackTrace(); &#125; &#125;; &#125; &#125; 简单配置如果不需要进行复杂的日志配置，则在配置文件中进行简单的日志配置即可，默认情况下，SpringBoot日志只记录到控制台，不写日志文件。如果希望在控制台输出之外编写日志文件，则需要进行配置 12345logging: path: /Users/Administrator/Desktop/杂七杂八/ims #日志文件路径 file: ims.log #日志文件名称 level: root: info #日志级别 root表示所有包，也可以单独配置具体包 fatal error warn info debug trace off 重新启动项目 扩展配置Spring Boot包含许多Logback扩展，可以帮助进行高级配置。您可以在您的logback-spring.xml配置文件中使用这些扩展。如果需要比较复杂的配置，建议使用扩展配置的方式 PS：SpringBoot推荐我们使用带-spring后缀的 logback-spring.xml 扩展配置，因为默认的的logback.xml标准配置，Spring无法完全控制日志初始化。（spring扩展对springProfile节点的支持） 以下是项目常见的完整logback-spring.xml，SpringBoot默认扫描classpath下面的logback.xml、logback-spring.xml，所以不需要再指定spring.logging.config，当然，你指定也没有问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\"&gt; &lt;!--日志文件主目录：这里$&#123;user.home&#125;为当前服务器用户主目录--&gt; &lt;property name=\"LOG_HOME\" value=\"$&#123;user.home&#125;/log\"/&gt; &lt;!--日志文件名称：这里spring.application.name表示工程名称--&gt; &lt;springProperty scope=\"context\" name=\"APP_NAME\" source=\"spring.application.name\"/&gt; &lt;!--默认配置--&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/&gt; &lt;!--配置控制台(Console)--&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!--配置日志文件(File)--&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--设置策略--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件路径：这里%d&#123;yyyyMMdd&#125;表示按天分类日志--&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/%d&#123;yyyyMMdd&#125;/$&#123;APP_NAME&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志保留天数--&gt; &lt;MaxHistory&gt;15&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;!--设置格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;!-- 或者使用默认配置 --&gt; &lt;!--&lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;--&gt; &lt;charset&gt;utf8&lt;/charset&gt; &lt;/encoder&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- 多环境配置 按照active profile选择分支 --&gt; &lt;springProfile name=\"dev\"&gt; &lt;!--root节点 全局日志级别，用来指定最基础的日志输出级别--&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt; &lt;!-- 子节点向上级传递 局部日志级别--&gt; &lt;logger level=\"WARN\" name=\"org.springframework\"/&gt; &lt;logger level=\"WARN\" name=\"com.netflix\"/&gt; &lt;logger level=\"DEBUG\" name=\"org.hibernate.SQL\"/&gt; &lt;/springProfile&gt; &lt;springProfile name=\"prod\"&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 启动项目，去到${user.home}当前服务器用户主目录，日志按日期进行产生，如果项目产生的日志文件比较大，还可以按照小时进行.log文件的生成 当然，使用简单配置照样能进行按日期分类 12345logging: path: $&#123;user.home&#125;/log/%d&#123;yyyyMMdd&#125; #日志文件路径 这里$&#123;user.home&#125;为当前服务器用户主目录 file: $&#123;spring.application.name&#125;.log #日志文件名称 $&#123;spring.application.name&#125;为应用名 level: root: info #日志级别 root表示所有包，也可以单独配置具体包 fatal error warn info debug trace off 输出到Web页面我们已经有日志文件.log了，为什么还要这个功能呢？（滑稽脸）为了偷懒！ 当我们把项目部署到Linux服务器，当你想看日志文件，还得打开xshell连接，定位到log文件夹，麻烦；如果我们把日志输出到Web页面，当做超级管理员或者测试账号下面的一个功能，点击就开始实时获取生成的日志并输出在Web页面，是不是爽很多呢？ PS：这个功能可得小心使用，因为日志会暴露很多信息 LoggingWSServer使用WebSocket实现实时获取，建立WebSocket连接后创建一个线程任务，每秒读取一次最新的日志文件，第一次只取后面200行，后面取相比上次新增的行，为了在页面上更加方便的阅读日志，对日志级别单词进行着色（PS：如何创建springboot的websocket，请戳：SpringBoot系列——WebSocket） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package cn.huanzi.qch.springbootlogback;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.thymeleaf.util.StringUtils;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * WebSocket获取实时日志并输出到Web页面 */@Slf4j@Component@ServerEndpoint(value = \"/websocket/logging\", configurator = MyEndpointConfigure.class)public class LoggingWSServer &#123; @Value(\"$&#123;spring.application.name&#125;\") private String applicationName; /** * 连接集合 */ private static Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;String, Session&gt;(); private static Map&lt;String, Integer&gt; lengthMap = new ConcurrentHashMap&lt;String, Integer&gt;(); /** * 连接建立成功调用的方法 */ @OnOpen public void onOpen(Session session) &#123; //添加到集合中 sessionMap.put(session.getId(), session); lengthMap.put(session.getId(), 1);//默认从第一行开始 //获取日志信息 new Thread(() -&gt; &#123; log.info(\"LoggingWebSocketServer 任务开始\"); boolean first = true; while (sessionMap.get(session.getId()) != null) &#123; BufferedReader reader = null; try &#123; //日志文件路径，获取最新的 String filePath = System.getProperty(\"user.home\") + \"/log/\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"/\"+applicationName+\".log\"; //字符流 reader = new BufferedReader(new FileReader(filePath)); Object[] lines = reader.lines().toArray(); //只取从上次之后产生的日志 Object[] copyOfRange = Arrays.copyOfRange(lines, lengthMap.get(session.getId()), lines.length); //对日志进行着色，更加美观 PS：注意，这里要根据日志生成规则来操作 for (int i = 0; i &lt; copyOfRange.length; i++) &#123; String line = (String) copyOfRange[i]; //先转义 line = line.replaceAll(\"&amp;\", \"&amp;amp;\") .replaceAll(\"&lt;\", \"&amp;lt;\") .replaceAll(\"&gt;\", \"&amp;gt;\") .replaceAll(\"\\\"\", \"&amp;quot;\"); //处理等级 line = line.replace(\"DEBUG\", \"&lt;span style='color: blue;'&gt;DEBUG&lt;/span&gt;\"); line = line.replace(\"INFO\", \"&lt;span style='color: green;'&gt;INFO&lt;/span&gt;\"); line = line.replace(\"WARN\", \"&lt;span style='color: orange;'&gt;WARN&lt;/span&gt;\"); line = line.replace(\"ERROR\", \"&lt;span style='color: red;'&gt;ERROR&lt;/span&gt;\"); //处理类名 String[] split = line.split(\"]\"); if (split.length &gt;= 2) &#123; String[] split1 = split[1].split(\"-\"); if (split1.length &gt;= 2) &#123; line = split[0] + \"]\" + \"&lt;span style='color: #298a8a;'&gt;\" + split1[0] + \"&lt;/span&gt;\" + \"-\" + split1[1]; &#125; &#125; copyOfRange[i] = line; &#125; //存储最新一行开始 lengthMap.put(session.getId(), lines.length); //第一次如果太大，截取最新的200行就够了，避免传输的数据太大 if(first &amp;&amp; copyOfRange.length &gt; 200)&#123; copyOfRange = Arrays.copyOfRange(copyOfRange, copyOfRange.length - 200, copyOfRange.length); first = false; &#125; String result = StringUtils.join(copyOfRange, \"&lt;br/&gt;\"); //发送 send(session, result); //休眠一秒 Thread.sleep(1000); &#125; catch (Exception e) &#123; //捕获但不处理 e.printStackTrace(); &#125; finally &#123; try &#123; reader.close(); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; log.info(\"LoggingWebSocketServer 任务结束\"); &#125;).start(); &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose(Session session) &#123; //从集合中删除 sessionMap.remove(session.getId()); lengthMap.remove(session.getId()); &#125; /** * 发生错误时调用 */ @OnError public void onError(Session session, Throwable error) &#123; error.printStackTrace(); &#125; /** * 服务器接收到客户端消息时调用的方法 */ @OnMessage public void onMessage(String message, Session session) &#123; &#125; /** * 封装一个send方法，发送消息到前端 */ private void send(Session session, String message) &#123; try &#123; session.getBasicRemote().sendText(message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; HTML页面页面收到数据就追加到div中，为了方便新增了几个功能： 清屏，清空div内容 滚动至底部、将div的滚动条滑到最下面 开启/关闭自动滚动，div新增内容后自动将滚动条滑到最下面，点一下开启，再点关闭，默认关闭 PS：引入公用部分，就是一些jquery等常用静态资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE&gt;&lt;!--解决idea thymeleaf 表达式模板报红波浪线--&gt;&lt;!--suppress ALL --&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;IMS实时日志&lt;/title&gt; &lt;!-- 引入公用部分 --&gt; &lt;script th:replace=\"head::static\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 标题 --&gt;&lt;h1 style=\"text-align: center;\"&gt;IMS实时日志&lt;/h1&gt;&lt;!-- 显示区 --&gt;&lt;div id=\"loggingText\" contenteditable=\"true\" style=\"width:100%;height: 600px;background-color: ghostwhite; overflow: auto;\"&gt;&lt;/div&gt;&lt;!-- 操作栏 --&gt;&lt;div style=\"text-align: center;\"&gt; &lt;button onclick=\"$('#loggingText').text('')\" style=\"color: green; height: 35px;\"&gt;清屏&lt;/button&gt; &lt;button onclick=\"$('#loggingText').animate(&#123;scrollTop:$('#loggingText')[0].scrollHeight&#125;);\" style=\"color: green; height: 35px;\"&gt;滚动至底部 &lt;/button&gt; &lt;button onclick=\"if(window.loggingAutoBottom)&#123;$(this).text('开启自动滚动');&#125;else&#123;$(this).text('关闭自动滚动');&#125;;window.loggingAutoBottom = !window.loggingAutoBottom\" style=\"color: green; height: 35px; \"&gt;开启自动滚动 &lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script th:inline=\"javascript\"&gt; //websocket对象 let websocket = null; //判断当前浏览器是否支持WebSocket if ('WebSocket' in window) &#123; websocket = new WebSocket(\"ws://localhost:10086/websocket/logging\"); &#125; else &#123; console.error(\"不支持WebSocket\"); &#125; //连接发生错误的回调方法 websocket.onerror = function (e) &#123; console.error(\"WebSocket连接发生错误\"); &#125;; //连接成功建立的回调方法 websocket.onopen = function () &#123; console.log(\"WebSocket连接成功\") &#125;; //接收到消息的回调方法 websocket.onmessage = function (event) &#123; //追加 if (event.data) &#123; //日志内容 let $loggingText = $(\"#loggingText\"); $loggingText.append(event.data); //是否开启自动底部 if (window.loggingAutoBottom) &#123; //滚动条自动到最底部 $loggingText.scrollTop($loggingText[0].scrollHeight); &#125; &#125; &#125; //连接关闭的回调方法 websocket.onclose = function () &#123; console.log(\"WebSocket连接关闭\") &#125;;&lt;/script&gt;&lt;/html&gt; 后记有了日志记录，我们以后写代码时就要注意了，应使用下面的正确示例 1234567//错误示例，这样写只会输出到控制台，不会输出到日志中System.out.println(\"XXX\");e.printStackTrace();//正确示例，既输出到控制台，又输出到日志log.info(\"XXX\");log.error(\"XXX报错\",e); SpringBoot日志暂时先记录到这里，点击官网了解更多：https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging 异步输出日志 异步输出日志的方式很简单，添加一个基于异步写日志的appender，并指向原先配置的appender即可 12345678910111213141516171819&lt;!-- 将文件输出设置成异步输出 --&gt; &lt;appender name=\"ASYNC-FILE\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;256&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;/appender&gt; &lt;!-- 将控制台输出设置成异步输出 --&gt; &lt;appender name=\"ASYNC-CONSOLE\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;256&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/appender&gt; 原理很简单，主线程将日志扔到阻塞队列中，然后IO操作日志写入文件是通过新起一个线程去完成的 代码开源代码已经开源、托管到我的GitHub、码云： GitHub：https://github.com/huanzi-qch/springBoot 码云：https://gitee.com/huanzi-qch/springBoot","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://ioufev.com/tags/日志/"}]},{"title":"springboot创建多模块","slug":"springboot创建多模块","date":"2019-12-13T02:07:33.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/12/13/springboot-chuang-jian-duo-mo-kuai/","link":"","permalink":"https://ioufev.com/2019/12/13/springboot-chuang-jian-duo-mo-kuai/","excerpt":"springboot创建多模块","text":"springboot创建多模块 参考：https://www.cnblogs.com/MaxElephant/p/8205234.html 最近在负责的是一个比较复杂项目，模块很多，代码中的二级模块就有9个，部分二级模块下面还分了多个模块。代码中的多模块是用maven管理的，每个模块都使用spring boot框架。之前有零零散散学过一些maven多模块配置的知识，但没自己从头到尾创建和配置过，也快忘得差不多了。这次正好对照着这个项目，动手实践一下，下面我们就开始吧。 maven多模块项目通常由一个父模块和若干个子模块构成，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块）相互关联。多模块适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。 多模块项目创建因为本系列的下一篇是《Spring Boot集成Dubbo》，所以本章就以创建多模块的dubbo项目作为示例。示例中的开发环境是Win 7，编辑器是Intellij IDEA，Java版本是1.8。 父模块创建首先我们在IDEA中创建一个spring boot工程作为父项目。 一、在界面左上角选择File-&gt;New-&gt;Project后，选择Spring Initializr，默认使用的Java版本是1.8。 二、点击Next，进入下一步，可以设置项目的一些基本信息。 这里我们先来温习下groupId、artifactId、package这三个参数的一般填写规范。 groupId和artifactId统称为“坐标”，是为了保证项目唯一性而提出的。groupId是项目组织唯一的标识符，实际对应JAVA的包的结构，ArtifactID是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。groupId一般分为多个段，一般第一段为域，第二段为公司名称。举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org，公司名称是apache，artifactId是tomcat。包结构package最好是以groupId.artifactId打头的。 因为后续打算将“代码学习和实践”写成一个系列的文章，文中演示的工程都作为该工程的子模块，所以这里项目名Name就填写CodeLearnAndPractice。 这里是个人练习的项目，不涉及公司名，但groupId、artifactId、package参数的填写，还是尽量按照上面的规范来填写，这里package就直接用groupId.artifactId。如下所示： 三、点击Next，进入下一个选择dependency的界面，作用是在pom中自动添加一些依赖，在项目开始时就下载。这里我们暂时不勾选任何依赖。 四、点击Next，进入下一个界面，填写工程名，并选择工程所在目录。填写完成后，点击Finish，即可创建一个spring boot项目。 创建子模块在上面创建好的CodeLearnAndPractice工程名上，点击右键，选择New–&gt;Module，进入New Module页面。 该模块为dubbo服务的提供方，Name为springboot-dubbo-server，后面其他的参数都可参照父模块的参数设置。 下面创建另一个Module，dubbo服务的调用方，Name为springboot-dubbo-client，其他参数设置参照上步。 以上3个模块创建完成之后，整个项目的目录结构如下图所示。 我们把下图选中的无用的文件及文件夹删掉，包括三个模块的mvnw、mvnw.cmd文件及.mvn文件夹，还有父模块的src目录，因为此处的父模块只做依赖管理，不需要编写代码。 到这里，一个父模块和两个子模块都创建完成啦~~ 多模块项目配置父模块pom配置父pom是为了抽取统一的配置信息和依赖版本控制，方便子pom直接引用，简化子pom的配置。 下面介绍下父pom的配置中需要注意的一些地方。我贴出的pom看起来会有点冗余，因为其中一些不需要的地方，我没有直接删掉而是注释掉，并加了说明，是为了后续查看的时候还能清楚删掉的原因。 1、父模块的打包类型 多模块项目中，父模块打包类型必须是pom，同时以给出所有的子模块，其中每个module，都是另外一个maven项目。 我们的项目中目前一共有两个子模块，springboot-dubbo-server和springboot-dubbo-client。后续新增的子模块也必须加到父pom的modules中。 2、继承设置 继承是maven中很强大的一种功能，继承可以使子pom获得parent中的各项配置，对子pom进行统一的配置和依赖管理。父pom中的大多数元素都能被子pom继承，想深入了解的同学可自行搜索学习~~ maven项目之间的继承关系通过表示。这里使用的开发框架是spring boot，默认继承spring-boot-starter-parent。 3、使用dependencyManagement管理依赖版本号 一般在项目最顶层的父pom中使用该元素，让所有子模块引用一个依赖而不用显式的列出版本号。maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。 4、使用properties控制依赖包的版本号，便于版本维护 在properties标签中，添加各依赖包的版本号，然后在dependency中直接引用该依赖版本号的值即可。 spring-boot-multi-module-demo/pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- parent指明继承关系，给出被继承的父项目的具体信息--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-multi-module-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-multi-module-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!--&lt;packaging&gt;jar&lt;/packaging&gt;--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--父模块打包类型必须为pom--&gt; &lt;modules&gt; &lt;module&gt;spring-boot-dubbo-server&lt;/module&gt; &lt;module&gt;spring-boot-dubbo-client&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- 在properties中统一控制依赖包的版本，更清晰--&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;!--dependencyManagement用于管理依赖版本号--&gt; &lt;dependencies&gt; &lt;!-- 删除spring-boot-starter和spring-boot-starter-test， 因为parent中继承的祖先中已经有了，并且一般dependencyManagement管理的依赖都要写版本号 --&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;--&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;!-- &lt;exclusions&gt;--&gt; &lt;!-- &lt;exclusion&gt;--&gt; &lt;!-- &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/exclusion&gt;--&gt; &lt;!-- &lt;/exclusions&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;!--新增后续dubbo项目中所需依赖，dubbo、zk--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!--&lt;version&gt;2.5.3&lt;/version&gt;--&gt; &lt;!--使用properties中配置的版本号--&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;!--&lt;version&gt;0.10&lt;/version&gt;--&gt; &lt;!--使用properties中配置的版本号--&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--该插件作用是打一个可运行的包，必须要写在需要打包的项目里。这里的父模块不需要打包运行，所以删掉该插件。--&gt; &lt;!-- &lt;build&gt;--&gt; &lt;!-- &lt;plugins&gt;--&gt; &lt;!-- &lt;plugin&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/plugin&gt;--&gt; &lt;!-- &lt;/plugins&gt;--&gt; &lt;!-- &lt;/build&gt;--&gt;&lt;/project&gt; 子模块pom配置1、继承设置 子模块的parent要使用顶层的父模块. 2、依赖设置 父模块pom中使用dependencyManagement来管理的依赖，在子模块pom中就不需要再写版本号了，exclusion元素也不需要再写。 spring-boot-dubbo-server/pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 子模块的parent要使用顶层的父模块--&gt; &lt;parent&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;--&gt; &lt;!-- &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;--&gt; &lt;!-- &lt;relativePath/&gt; &amp;lt;!&amp;ndash; lookup parent from repository &amp;ndash;&amp;gt;--&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-multi-module-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dubbo-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-dubbo-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- properties可删掉，会继承父模块的--&gt; &lt;!-- &lt;properties&gt;--&gt; &lt;!-- &lt;java.version&gt;1.8&lt;/java.version&gt;--&gt; &lt;!-- &lt;/properties&gt;--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--新增后续dubbo项目中所需依赖，dubbo、zk。 父模块pom中使用dependencyManagement来管理依赖版本号，子模块pom中不需要再写版本号，exclusion也不需要--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!--&lt;version&gt;2.5.3&lt;/version&gt;--&gt; &lt;!--&lt;exclusions&gt;--&gt; &lt;!--&lt;exclusion&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring&lt;/artifactId&gt;--&gt; &lt;!--&lt;/exclusion&gt;--&gt; &lt;!--&lt;/exclusions&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;!--&lt;version&gt;0.10&lt;/version&gt;--&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; spring-boot-dubbo-client/pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 子模块的parent要使用顶层的父模块--&gt; &lt;parent&gt;&lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;--&gt;&lt;!-- &lt;relativePath/&gt; &amp;lt;!&amp;ndash; lookup parent from repository &amp;ndash;&amp;gt;--&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-multi-module-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dubbo-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-dubbo-client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- properties可删掉，会继承父模块的--&gt;&lt;!-- &lt;properties&gt;--&gt;&lt;!-- &lt;java.version&gt;1.8&lt;/java.version&gt;--&gt;&lt;!-- &lt;/properties&gt;--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 该模块需要启动web服务，需要该依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--新增后续dubbo项目中所需依赖，dubbo、zk 父模块pom中使用dependencyManagement来管理依赖版本号，子模块pom中不需要再写版本号 父模块pom中里有exclusion，子模块pom中不要写exclusion--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!--&lt;version&gt;2.5.3&lt;/version&gt;--&gt; &lt;!--&lt;exclusions&gt;--&gt; &lt;!--&lt;exclusion&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring&lt;/artifactId&gt;--&gt; &lt;!--&lt;/exclusion&gt;--&gt; &lt;!--&lt;/exclusions&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;!--&lt;version&gt;0.10&lt;/version&gt;--&gt; &lt;/dependency&gt; &lt;!--client模块需要依赖server模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ioufev&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dubbo-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、关于exclusions标签 当dependency A自身的依赖B，与其他dependency存在冲突的时候（最常见的就是版本冲突），我们就需要把B排除掉，这时就需要使用exclusions元素。 那么我们怎么知道一个dependency自身包含哪些依赖呢？ 1、通过mvn dependency:tree命令查看依赖树2、使用IDEA或其他IDA查看依赖树 点击IDEA右侧的Maven Projects，在每个模块的Dependencies中即可查看每个dependency内部的依赖及版本号，从来识别哪些依赖需要被排除掉。 以dubbo为例，我们先删除配置，点开Maven Projects，可以看到2.5.3版本的dubbo中使用的spring版本是2.5.6，这是一个很老的版本，有一些方法是没有的，现在在用的spring版本一般都是4.*的，所以我们需要把它排除掉，避免后续报错。 要查看当前项目中使用的spring版本，可以点击前面“三角”，然后点击父pom中的值，进入更上一层pom，再重复上步操作，可以看到spring的版本是4.3.12。 测试这里就先不写代码了，到下一章再写。直接编译一下，如果编译成功，说明pom文件的配置没有什么大问题。 点开右侧Maven Projects，双击父模块Lifecycle中的compile，进行代码编译，或者直接在Terminal中执行命令：mvn compile。 编译通过啦~~","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://ioufev.com/tags/springboot/"}]},{"title":"JAVA注解","slug":"JAVA注解","date":"2019-12-11T02:07:33.000Z","updated":"2021-08-17T13:21:19.699Z","comments":true,"path":"2019/12/11/java-zhu-jie/","link":"","permalink":"https://ioufev.com/2019/12/11/java-zhu-jie/","excerpt":"JAVA注解","text":"JAVA注解 来源：https://www.jianshu.com/p/b6482d615a51 注解的作用Annotation(注解)是JDK 5.0引入的特性，它的基本作用就是修饰编程元素。 注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。编译器、开发工具或其他程序可以用反射来了解该类，有什么样的标记，就去干相应的事。 注解的语法比较简单，除了@符号的使用之外，与Java固有语法一致。JDK 5.0内置了三种标准注解： @Override：表示当前的方法定义将覆盖父类中的方法。 @Deprecated：表示当前元素不推荐使用，是被弃用的代码。 @SuppressWarnings：忽略编译器发出的警告信息。 注解有以下几个作用： 生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see 、@param 、@return 等 跟踪代码依赖性，替代配置文件的功能(相当于配置文件)。比如Spring从 2.5版本 开始支持基于注解的配置。现在的框架基本都使用了注解来减少配置文件的数量。 在编译时进行格式检查。如@override 放在方法前，如果这个方法并不是覆盖了父类方法，则编译时就能检查出来。 元注解Java 5.0提供了四种元注解——负责注解其他注解。 @Target@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围，即该注解可以用在什么地方。 取值(ElementType枚举类)有： CONSTRUCTOR：用于描述构造器 FIELD：用于描述变量 LOCAL_VARIABLE：用于描述局部变量 METHOD：用于描述方法 PACKAGE：用于描述包 PARAMETER：用于描述方法参数 TYPE：用于描述类、接口(包括注解类型) 或enum声明 1234567891011121314151617@Target:注解的作用目标@Target(ElementType.TYPE) //接口、类、枚举@Target(ElementType.FIELD) //字段、枚举的常量@Target(ElementType.METHOD) //方法@Target(ElementType.PARAMETER) //方法参数@Target(ElementType.CONSTRUCTOR) //构造函数@Target(ElementType.LOCAL_VARIABLE)//局部变量@Target(ElementType.ANNOTATION_TYPE)//注解@Target(ElementType.PACKAGE) ///包 @Retention@Retention定义了该注解被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用@Retention可以限制注解的“生命周期”。 作用：用于描述注解的生命周期，即注解在什么范围内有效。 取值（RetentionPoicy枚举类）有： SOURCE：在源文件中有效 (.java) CLASS：在class文件中有效 (.class) RUNTIME：在运行时有效 1234567@Retention：注解的保留位置 @Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到 @Documented@Documented是一种标记性注解，被其标记的注解会被包含在javadoc文档中。 说明该注解将被包含在javadoc中 @Inherited说明子类可以继承父类中的该注解 @Inherited 也是一种标记性注解，被其标记的注解会允许子类继承。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则该注解将被用于该class的子类。 需要注意的是，被@Inheriten标记的注解只会被class的子类所继承，类并不从它所实现的接口继承annotation，方法也不从它所重载的方法继承annotation。 如果我们使用java.lang.reflect去查询一个@Inherited类型的annotation时，反射代码将检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 自定义注解自定义注解的格式为： 1public @interface 注解名 &#123;定义体&#125; 例如： 123456789@Target(value = &#123; ElementType.FIELD &#125;)@Retention(value = RetentionPolicy.RUNTIME)@Documentedpublic @interface NotNull &#123; int code() default -1; String message() default \"\";&#125; @interface 用来声明一个注解，自动继承了java.lang.annotation.Annotation接口，在自定义注解时，不能继承其他的注解或接口。 定义体中的每一个方法实际上是声明了一个配置参数，方法只能用public或默认(default)两种访问权修饰，方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 注解参数支持数据类型： 所有基本数据类型（byte,int,short.long,double,float,boolean,char） String类型 Class类型 Enum类型 Annotation类型 以上所有类型的数组 注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难判断一个元素是否缺失，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。 如果成员名称是value，在赋值过程中可以简写；如果成员类型为数组，但是只赋值一个元素，则也可以简写。上面的例子可以简写为： 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface NotNull &#123; int code() default -1; String message() default \"\";&#125; 上例自定义了名为@NotNull的注解，作用对象为field，其目的是对类变量进行非空检验。可是，到底怎么怎么利用它来进行检验呢？ 使用注解最主要的部分在于对注解的处理，那么就会涉及到注解处理器。从原理上讲，注解处理器就是通过反射机制获取被检查字段上的注解信息，然后根据注解元素的值进行特定的处理。 比如，在某网站注册用户，用户输入的信息会被封装成一个User对象： 12345678910111213141516171819202122232425262728293031323334public class User &#123; @NotNull(message = \"用户昵称不能为空\") private String userName; @NotNull(message = \"密码不能为空\") private String password; private Integer age; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 要求用户昵称与密码不能为空，因此userName与password字段被@NotNull注解。 后台程序接收到User对象后，可以通过反射机制探知哪些字段被@NotNull注解了，如果全部满足要求再进行下一步业务逻辑；反之，返回错误页面。 12345678910111213141516171819202122232425public class UserTest &#123; public static boolean testNotNull(User user) throws IllegalArgumentException, IllegalAccessException &#123; Class&lt;?&gt; clazz = user.getClass(); // 获取User的Class对象 Field[] userFields = clazz.getDeclaredFields(); // 获取User的所有Field对象 for (Field field : userFields) &#123; field.setAccessible(true); // User中的Field都是private的，所以要先setAccessible NotNull notNullAnnotation = field.getAnnotation(NotNull.class); // 获取Field的NotNull注解对象 if (notNullAnnotation != null) &#123; // 如果该Field被NotNull注解了，那么字段不能为空 if (field.get(user) == null) &#123; System.out.println(notNullAnnotation.message()); return false; &#125; &#125; &#125; return true; &#125; public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException &#123; User user = new User(); user.setUserName(\"chenlongfei\"); testNotNull(user); &#125;&#125; 由于只填写了昵称而没填密码，不能通过验证，控制台打印出： 密码不能为空 而该信息正是在@NotNull注解password字段时由message定义的。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://ioufev.com/tags/注解/"}]},{"title":"Maven配置文件","slug":"Maven配置文件","date":"2019-12-11T02:07:33.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/12/11/maven-pei-zhi-wen-jian/","link":"","permalink":"https://ioufev.com/2019/12/11/maven-pei-zhi-wen-jian/","excerpt":"Maven之pom.xml配置文件详解","text":"Maven之pom.xml配置文件详解 来源：https://blog.csdn.net/qq_33363618/article/details/79438044 setting.xml主要用于配置maven的运行环境等一系列通用的属性，是全局级别的配置文件；而pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。 基础配置一个典型的pom.xml文件配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.winner.trade，maven会将该项目打成的jar包放本地路径：/com/winner/trade --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;trade-core&lt;/artifactId&gt; &lt;!-- 本项目目前所处的版本号 --&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的机制，如pom,jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 --&gt; &lt;classifier&gt;...&lt;/classifier&gt; &lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），--&gt; &lt;!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt; &lt;/properties&gt; ... &lt;/project&gt; 一般来说，上面的几个配置项对任何项目都是必不可少的，定义了项目的基本属性。 这里有必要对一个不太常用的属性classifier做一下解释，因为有时候引用某个jar包，classifier不写的话会报错。 classifier元素用来帮助定义构件输出的一些附属构件。附属构件与主构件对应，比如主构件是 kimi-app-2.0.0.jar，该项目可能还会通过使用一些插件生成 如kimi-app-2.0.0-javadoc.jar （Java文档）、 kimi-app-2.0.0-sources.jar（Java源代码） 这样两个附属构件。这时候，javadoc、sources就是这两个附属构件的classifier，这样附属构件也就拥有了自己唯一的坐标。 classifier的用途在于: maven download javadoc / sources jar包的时候，需要借助classifier指明要下载那个附属构件 引入依赖的时候，有时候仅凭groupId、artifactId、version无法唯一的确定某个构件，需要借助classifier来进一步明确目标。比如JSON-lib，有时候会同一个版本会提供多个jar包，在JDK1.5环境下是一套，在JDK1.3环境下是一套： 引用它的时候就要注明JDK版本，否则maven不知道你到底需要哪一套jar包： 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; 构建配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;build&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName&gt;myPorjectName&lt;/finalName&gt; &lt;!-- 构建产生的所有文件存放的目录,默认为$&#123;basedir&#125;/target，即项目根目录下的target --&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;!--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值， --&gt; &lt;!--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 --&gt; &lt;defaultGoal&gt;install&lt;/defaultGoal&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表。 --&gt; &lt;!--项目配置信息中诸如$&#123;spring.version&#125;之类的占位符会被属性文件中的实际值替换掉 --&gt; &lt;filters&gt; &lt;filter&gt;../filter.properties&lt;/filter&gt; &lt;/filters&gt; &lt;!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 --&gt; &lt;!--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 --&gt; &lt;!--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;resources&lt;/targetPath&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!--包含的模式列表 --&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt; &lt;excludes&gt; &lt;exclude&gt;jdbc.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--单元测试相关的所有资源路径，配制方法与resources类似 --&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory&gt;$&#123;basedir&#125;\\src\\main\\java&lt;/sourceDirectory&gt; &lt;!--项目脚本源码目录，该目录和源码目录不同， &lt;!-- 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory&gt;$&#123;basedir&#125;\\src\\main\\scripts&lt;/scriptSourceDirectory&gt; &lt;!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory&gt;$&#123;basedir&#125;\\src\\test\\java&lt;/testSourceDirectory&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;\\target\\classes&lt;/outputDirectory&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory&gt;$&#123;basedir&#125;\\target\\test-classes &lt;/testOutputDirectory&gt; &lt;!--项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running bulid‘s classpath里面。 --&gt; &lt;!--他们可以开启extensions，也可以通过提供条件来激活plugins。 --&gt; &lt;!--简单来讲，extensions是在build过程被激活的产品 --&gt; &lt;extensions&gt; &lt;!--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、 --&gt; &lt;!--将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 --&gt; &lt;!--实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 --&gt; &lt;!--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， --&gt; &lt;!--类似的还有支持ftp方式的wagon-ftp插件 --&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groupId&gt; &lt;artifactId&gt;wagon-ssh&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;assembly&lt;/id&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!--配置的执行目标 --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited&gt;false&lt;/inherited&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--作为DOM对象的配置,配置项因插件而异 --&gt; &lt;configuration&gt; &lt;finalName&gt;$&#123;finalName&#125;&lt;/finalName&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/configuration&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器）， --&gt; &lt;!--由于性能原因，只有在真需要下载时，该元素才被设置成true。 --&gt; &lt;extensions&gt;false&lt;/extensions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt;...&lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， --&gt; &lt;!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 --&gt; &lt;!--给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;plugins&gt;...&lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; pom里面的仓库与setting.xml里的仓库功能是一样的。主要的区别在于，pom里的仓库是个性化的。比如一家大公司里的setting文件是公用的，所有项目都用一个setting文件，但各个子项目却会引用不同的第三方库，所以就需要在pom里设置自己需要的仓库地址。 分发配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。 --&gt; &lt;!--有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号 --&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;name&gt; repo-name&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; site-id &lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt; site-name&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。 --&gt; &lt;!--使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的groupID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。 --&gt; &lt;!--有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来）， --&gt; &lt;!--partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; 仓库配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。 --&gt; &lt;!--这里的选项是：always（一直），daily（默认，每日）， --&gt; &lt;!--interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做： --&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置， --&gt; &lt;!--POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 --&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt; repo-name&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 --&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局； --&gt; &lt;!--然而，Maven1.x有一种不同的布局。 --&gt; &lt;!--我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository /&gt; &lt;/pluginRepositories&gt; profile配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。 --&gt; &lt;!-- 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 --&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;id /&gt; &lt;build /&gt; &lt;modules /&gt; &lt;repositories /&gt; &lt;pluginRepositories /&gt; &lt;dependencies /&gt; &lt;reporting /&gt; &lt;dependencyManagement /&gt; &lt;distributionManagement /&gt; &lt;properties /&gt; &lt;/profile&gt; profile配置项在setting.xml中也有，是pom.xml中profile元素的裁剪版本，包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为setting.xml只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。pom.xml中的profile可以看做pom.xml的副本，拥有与pom.xml相同的子元素与配置方法。它包含可选的activation（profile的触发器）和一系列的changes。例如test过程可能会指向不同的数据库（相对最终的deployment）或者不同的dependencies或者不同的repositories，并且是根据不同的JDK来改变的。只需要其中一个成立就可以激活profile，如果第一个条件满足了，那么后面就不会在进行匹配。 报表配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!--描述使用报表插件产生报表的规范,特定的maven 插件能输出相应的定制和配置报表. --&gt; &lt;!--当用户执行“mvn site”，这些报表就会运行,在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;inherited /&gt; &lt;configuration&gt; &lt;links&gt; &lt;link&gt;http://java.sun.com/j2se/1.5.0/docs/api/&lt;/link&gt; &lt;/links&gt; &lt;/configuration&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。 --&gt; &lt;!--一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。 --&gt; &lt;!--1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id&gt;sunlink&lt;/id&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports&gt; &lt;report&gt;javadoc&lt;/report&gt; &lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; 环境配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.clf.com/&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; 项目信息配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;name&gt;banseon-maven &lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt;http://www.clf.com/ &lt;/url&gt; &lt;!--项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 --&gt; &lt;!--（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。 --&gt; &lt;!-- 如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt;A maven project to study maven. &lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; clf@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; clf@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; clf@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.clf.com/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt; banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager&lt;/role&gt; &lt;role&gt;Architect &lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt; demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.clf.com/ &lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 --&gt; &lt;!--如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.clf.com/LICENSE-2.0.txt &lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt; Abusiness-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt;scm:svn:http://svn.baidu.com/banseon/maven/&lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt;scm:svn:http://svn.baidu.com/banseon/maven/ &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt; http://www.clf.com/&lt;/url&gt; &lt;/organization&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://ioufev.com/tags/maven/"}]},{"title":"人人代码生成器","slug":"人人代码生成器","date":"2019-11-28T02:07:33.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/11/28/ren-ren-dai-ma-sheng-cheng-qi/","link":"","permalink":"https://ioufev.com/2019/11/28/ren-ren-dai-ma-sheng-cheng-qi/","excerpt":"人人代码生成器使用","text":"人人代码生成器使用 项目简单使用下载人人开源：https://www.renren.io/community/project 代码生成器：https://gitee.com/renrenio/renren-generator git下载：git clone https://gitee.com/rayson517/renren-generator.git 或者直接下载zip：https://gitee.com/renrenio/renren-generator/repository/archive/master.zip 下载后解压 可见，人人代码生成器本身就是一个SpringBoot项目，我们完全可以自己编写，其原理无非就是读取数据库拿到表结构，通过IO生成各种文件罢了，但是没必要重复造轮子，毕竟时间宝贵，我们打开这个项目： 安装sts导入已有maven项目 项目结构 运行修改配置文件：generator.properties 1234567891011121314#代码生成器，配置信息mainPath=com.tcb#包名package=com.tcb.modulesmoduleName=generator#作者author=abc#Emailemail=abcd@163.com#表前缀(类名不会包含表前缀)tablePrefix=tb_#类型转换，配置信息 修改配置文件：application.yml 默认是mysql，一般修改url和账号密码就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server: port: 80# mysqlspring: datasource: type: com.alibaba.druid.pool.DruidDataSource #MySQL配置 driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.50.24:3306/renren_fast?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false username: root password: 123456 #oracle配置 # driverClassName: oracle.jdbc.OracleDriver # url: jdbc:oracle:thin:@47.100.206.162:1521:xe # username: renren # password: 123456 #SQLServer配置 # driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver # url: jdbc:sqlserver://192.168.10.10:1433;DatabaseName=renren_fast # username: sa # password: 123456 #PostgreSQL配置 # driverClassName: org.postgresql.Driver # url: jdbc:postgresql://192.168.10.10:5432/renren_fast # username: postgres # password: 123456 jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss resources: static-locations: classpath:/static/,classpath:/views/mybatis: mapperLocations: classpath:mapper/**/*.xmlpagehelper: reasonable: true supportMethodsArguments: true params: count=countSql#指定数据库，可选值有【mysql、oracle、sqlserver、postgresql】renren: database: mysql 导入数据表 使用navicat，因为是测试，所以随意找了2个表 启动服务 浏览器打开：http://localhost ，可以看到刚才导入的2个数据表 生成代码 查看生成的代码 可以看到 Java代码 生成的文件 123456SysUserController.javaSysUserDao.javaSysUserEntity.javaSysUserService.javaSysUserServiceImpl.javaSysUserDao.xml Vue代码 生成的文件 12sysuser.vuesysuser-add-or-update.vue 项目深入项目使用的技术架构Renren-generator代码生成的思想主要是通过volocity模板并打成zip包的形式。 主要采用了volocity模板引擎和vue.js。 它的技术栈主要如下: 技术栈所包含的可以说，是我们绝大多数Java程序员比较熟悉的。 所以对于学习来说，成本并不高。特别具有技术栈所包含技术的使用经验的人。 项目结构如下: 项目实际使用问题代码生成器的作用在于提高开发效率。但是这个代码生成器仍有其局限性，因为它并不具有多表和级联相关的代码生成。只能针对单一的表而言。这是一个比较大的局限性。 模板自定义修改需要额外学习","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ioufev.com/categories/笔记/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://ioufev.com/tags/工具/"}]},{"title":"搭建Github博客：Next主题配置","slug":"搭建Github博客：Next主题配置","date":"2019-01-18T02:07:33.000Z","updated":"2020-01-01T07:48:56.802Z","comments":true,"path":"2019/01/18/da-jian-github-bo-ke-next-zhu-ti-pei-zhi/","link":"","permalink":"https://ioufev.com/2019/01/18/da-jian-github-bo-ke-next-zhu-ti-pei-zhi/","excerpt":"介绍搭建Github博客：Next主题配置","text":"介绍搭建Github博客：Next主题配置 NexT 使用文档：http://theme-next.iissnan.com 主题配置文件路径：D:\\CODE\\blog\\themes\\next\\_config.yml 站点配置文件路径：D:\\CODE\\blog\\_config.yml 主题设定：http://theme-next.iissnan.com/getting-started.html#theme-settings 主题配置：http://theme-next.iissnan.com/theme-settings.html 第三方服务集成：http://theme-next.iissnan.com/third-party-services.html#comment-system 1.主题设定选择「Scheme」Next主题还有4种风格供我们选择，预览 Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 设置「语言」编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：1language: zh-CN 比如，我的语言包路径是：D:\\CODE\\blog\\themes\\next\\languages 设置「菜单」菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： （1）设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html NexT 默认的菜单项有： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页(需要手动创建) tags tags: /tags 标签页(需要手动创建) about about: /about 关于页面(需要手动创建) commonweal commonweal: /404.html 公益 404 (需要手动创建) （2）设置菜单项的显示文本。 在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-CN.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 （3）设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置「侧栏」默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 （1）设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：12345#left - 靠左放置#right - 靠右放置sidebar: position: left 目前仅 Pisces Scheme 支持 position 配置 （2）设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： 123456#post - 默认行为，在文章页面（拥有目录列表）时显示#always - 在所有页面中都显示#hide - 在所有页面中都隐藏（可以手动展开）#remove - 完全移除sidebar: display: post 设置「头像」编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 头像设置示例1avatar: http://example.com/avatar.png 设置「作者昵称」编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 2.主题配置设置 RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 具体的链接地址：适用于已经烧制过 Feed 的情形。 添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 添加「分类」页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 设置字体为了解决 Google Fonts API 不稳定的问题，NexT 在 5.0.1 中引入此特性。 通过此特性，你可以指定所使用的字体库外链地址；与此同时，NexT 开放了 5 个特定范围的字体设定，他们是： 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties： 高亮主题设置示例 1234# Code Highlight theme# Available value: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 链接放置在 social 字段下，一行一个链接。其键值格式是 显示文本: 链接地址。 配置示例12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键: Font Awesome 图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是 Font Awesome 图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。 配置示例1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。 打赏功能配置示例 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 友情链接编辑 主题配置文件 添加： 友情链接配置示例12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件 配置示例1since: 2013 订阅微信公众号在每篇文章的末尾显示微信公众号二维码，扫一扫，轻松订阅博客。 在微信公众号平台下载您的二维码，并将它存放于博客source/uploads/目录下。 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。 编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可： canvas_nest 配置示例123# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画 1234three_waves 配置示例# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 3.配置记录头像搜索：avatar 比如我的头像是放在D:\\CODE\\blog\\themes\\next\\source\\images\\文件夹下的Elena.jpg 123# Sidebar Avataravatar: url: /images/Elena.jpg #/images/avatar.gif 手动页面","categories":[{"name":"生活","slug":"生活","permalink":"https://ioufev.com/categories/生活/"}],"tags":[{"name":"next","slug":"next","permalink":"https://ioufev.com/tags/next/"}]},{"title":"前后端均适用的网络知识点大全","slug":"前后端均适用的网络知识点大全","date":"2019-01-17T07:16:07.000Z","updated":"2019-12-23T11:43:18.584Z","comments":true,"path":"2019/01/17/qian-hou-duan-jun-gua-yong-de-wang-luo-zhi-shi-dian-da-quan/","link":"","permalink":"https://ioufev.com/2019/01/17/qian-hou-duan-jun-gua-yong-de-wang-luo-zhi-shi-dian-da-quan/","excerpt":"前后端均适用的网络知识点大全","text":"前后端均适用的网络知识点大全 来源：前端指南 https://mp.weixin.qq.com/s/hOKfbgd-nRn2lboXMCiY8w http 响应常见状态码 100-199 : 表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程 200-299: 表示成果接收请求并已完成整个处理过程. 常用 200 300-399: 为完成请求, 客户需进一步细化需求: 例如: 请求的资源已经移动一个新地址, 常用 302(重定向), 307 和 304(拿缓存) 400-499: 客户端的请求有错误, 包含语法错误或者不能正确执行. 常用 404(请求的资源在 web 服务器中没有) 403(服务器拒绝访问, 权限不够) 500-599: 服务器端出现错误 常用： 200 正常，表示一切正常, 返回的是正常请求结果 302/307 临时重定向，指出请求的文档已被临时移动到别处, 此文档的新的 url 在 location 响应头中给出 304 未修改，表示客户机缓存的版本是最新的, 客户机应该继续使用它 403 禁止，服务器理解客户端请求, 但拒绝处理它, 通常用于服务器上文件或目录的权限设置所致 404 找不到，服务器上不存在客户机所请求的资源 500 服务器内部错误，服务器端的 cgi, asp, jsp 等程序发生错误 简述 http 1.1 与 http 1.0 的区别 http 1.0 对于每个连接都得建立一次连接, 一次只能传送一个请求和响应, 请求就会关闭, http1.0 没有 Host 字段 而 http1.1 在同一个连接中可以传送多个请求和响应, 多个请求可以重叠和同时进行, http1.1 必须有 host 字段 http1.1 中引入了 ETag 头, 它的值 entity tag 可以用来唯一的描述一个资源. 请求消息中可以使用 If-None-Match 头域来匹配资源的 entitytag 是否有变化 http1.1 新增了 Cache-Control 头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集 http1.0 中只定义了 16 个状态响应码, 对错误或警告的提示不够具体. http1.1 引入了一个 Warning 头域, 增加对错误或警告信息的描述. 且新增了 24 个状态响应码 说一下 TCP 三次握手和四次挥手 建立 TCP 连接需要三次握手:三次握手: 首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。 第一步: 客户机的 TCP 先向服务器的 TCP 发送一个连接请求报文. 这个特殊的报文中不含应用层数据, 其首部中的 SYN 标志位被置 1. 另外, 客户机会随机选择一个起始序号 seq=x(连接请求报文不携带数据,但要消耗掉一个序号) 第二步: 服务器端的 TCP 收到连接请求报文后, 若同意建立连接, 就向客户机发送请求, 并为该 TCP 连接分配 TCP 缓存和变量. 在确认报文中,SYN 和 ACK 位都被置为 1, 确认号字段的值为 x+1, 并且服务器随机产生起始序号 seq=y(确认报文不携带数据, 但也要消耗掉一个序号). 确认报文同样不包含应用层数据. 第三步: 当客户机收到确认报文后, 还要向服务器给出确认, 并且也要给该连接分配缓存和变量. 这个报文的 ACK 标志位被置为 1, 序号字段为 x+1, 确认号字段为 y+1 四次挥手 第一步: 客户机打算关闭连接,就向其 TCP 发送一个连接释放报文,并停止再发送数据,主动关闭 TCP 连接, 该报文的 FIN 标志位被置 1, seq=u, 它等于前面已经传送过的数据的最后一个字节的序号加 1(FIN 报文即使不携带数据,也要消耗掉一个序号) 第二步: 服务器接收连接释放报文后即发出确认, 确认号是 ack=u+1, 这个报文自己的序号是 v, 等于它前面已传送过的数据的最后一个自己的序号加 1. 此时, 从客户机到服务器这个方向的连接就释放了, TCP 连接处于半关闭状态. 但服务器若发送数据, 客户机仍要接收, 即从服务器到客户机的连接仍未关闭. 第三步: 若服务器已经没有了要向客户机发送的数据, 就通知 TCP 释放连接, 此时其发出 FIN=1 的连接释放报文 第四步: 客户机收到连接释放报文后, 必须发出确认. 在确认报文中, ACK 字段被置为 1, 确认号 ack=w+1, 序号 seq=u+1. 此时, TCP 连接还没有释放掉, 必须经过等待计时器设置的时间 2MSL 后, A 才进入到连接关闭状态. 计算机网络体系结构有哪些 学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 应用层应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。 域名系统 域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco 公司的域名是 www.cisco.com 等。 http 协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科） 运输层运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。 运输层常用的两种协议TCP UDP 传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。 用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 UDP的主要特点 UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 TCP的主要特点 TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）； TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 网络层在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。 这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。 这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称. 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 物理层在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。 上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：https://blog.csdn.net/yaopeng_2005/article/details/7064869 HTTP与HTTPS的区别（常考） Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同： 端口不同：Http 与 Http 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443； 资源消耗：和 HTTP 通信相比，Https 通信会由于加减密处理消耗更多的 CPU 和内存资源； 开销：Https 通信需要证书，而证书一般需要向认证机构购买； Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 对称加密与非对称加密 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 TCP协议如何来保持传输的可靠性TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。 对于可靠性，TCP 通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据； 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 参考链接 计算机网络面试问题集锦 简述 查找域名对应的IP地址这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： LDNS 向 Root Name Server （根域名服务器，如 com、net、org 等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 从输入 URL 到页面加载发生了什么【必考】总体来说分为以下几个过程: DNS 解析 TCP 连接 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 连接结束 这道题的区分度很高建议大家仔细查看下面这篇文章从输入 URL 到页面加载发生了什么 HTTP的几种请求方法的用途 GET 方法：发送一个请求来取得服务器上的某一资源 POST 方法：向 URL 指定的资源提交数据或附加新的数据 PUT 方法：跟 POST 方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT 指定了资源在服务器上的位置，而 POST 没有 HEAD 方法：只请求页面的首部 DELETE 方法：删除服务器上的某资源 OPTIONS 方法：它用于获取当前 URL 所支持的方法。如果请求成功，会有一个 Allow 的头包含类似“GET,POST”这样的信息 TRACE 方法：TRACE 方法被用于激发一个远程的，应用层的请求消息回路 CONNECT 方法：把请求连接转换到透明的 TCP/IP 通道 127.0.0.1 与 192.168.0.1 有什么区别【可能考】首先明确二者没有区别！两个 IP 地址的角度不一样，127.0.0.1 是从 IETF（因特尔工程任务组）规定看，是保留给本机使用的 IP 地址，所有的计算机默认都是相同的。而 192.168.0.1 其实只是 IETF 在 c 类网址中，专门留出给专用网络用的一个网段中的一个 IP 而已，该网段包含了 192.168.0.1 到 192.168.255.255 中所有的 IP 地址。 五类 ip 地址的范围IP 地址分为 A,B,C,D,E 五类。 网络号：用于识别主机所在的网络； 主机号：用于识别该网络中的主机。 其中 A 类分配给政府机关使用，B 类地址给大中型企业使用，C 类地址给个人使用。这三种是主要的。 IP 地址分为五类，A 类保留给政府机构，B 类分配给中等规模的公司，C 类分配给任何需要的人，D 类用于组播，E 类用于实验，各类可容纳的地址数目不同。 其中 A 类、B 类、和 C 类这三类地址用于 TCP/IP 节点，其它两类 D 类和 E 类被用于特殊用途。 A、B、C 三类 IP 地址的特征：当将 IP 地址写成二进制形式时，A 类地址的第一位总是 O，B 类地址的前两位总是 10，C 类地址的前三位总是 110。 A 类地址 ⑴ A 类地址第 1 字节为网络地址，其它 3 个字节为主机地址。 ⑵ A 类地址范围：1.0.0.1—126.155.255.254 ⑶ A 类地址中的私有地址和保留地址： ① 10.X.X.X 是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。 ② 127.X.X.X 是保留地址，用做循环测试用的。 B 类地址 ⑴ B 类地址第 1 字节和第 2 字节为网络地址，其它 2 个字节为主机地址。 ⑵ B 类地址范围：128.0.0.1—191.255.255.254。 ⑶ B 类地址的私有地址和保留地址 ① 172.16.0.0—172.31.255.255 是私有地址 ② 169.254.X.X 是保留地址。如果你的 IP 地址是自动获取 IP 地址，而你在网络上又没有找到可用的 DHCP 服务器。就会得到其中一个 IP。 C 类地址 ⑴ C 类地址第 1 字节、第 2 字节和第 3 个字节为网络地址，第 4 个个字节为主机地址。另外第 1 个字节的前三位固定为 110。 ⑵ C 类地址范围：192.0.0.1—223.255.255.254。 ⑶ C 类地址中的私有地址： 192.168.X.X 是私有地址。 D 类地址 ⑴ D 类地址不分网络地址和主机地址，它的第 1 个字节的前四位固定为 1110。 ⑵ D 类地址范围：224.0.0.1—239.255.255.254 E 类地址 ⑴ E 类地址也不分网络地址和主机地址，它的第 1 个字节的前五位固定为 11110。 ⑵ E 类地址范围：240.0.0.1—255.255.255.254 HTTP 长连接、短连接在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。 而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码： Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。 HTTP 长连接、短连接究竟是什么？ 如何理解 HTTP 协议是无状态的【常考】HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 各种协议与 HTTP 协议之间的关系一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。 Socket 连接与 HTTP 连接的联系与区别（需了解）由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。 而 HTTP 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。 很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给客户端;若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。 http 报文大小限制如前所述，一个 HTTP 报文包含起始行，头域和消息体，HTTP 协议本身并没有对报文中任一部分的长度做限制，也就是说，理论上一个请求 URI 可以无限长，头域可以无限多，请求体可以无限大。但在实际场景下，请求 URI 的长度会受到浏览器的限制，如果在浏览器中输入过长的 URL，那么浏览器会自动进行截断。而服务器出于安全性和效率的考虑，也会对头域和消息体的大小作出一定的限制。 http(tcp) 报文结构（必考）例如一个 100kb 的 HTML 文档需要传送到另外一台计算机，并不会整个文档直接传送过去，可能会切割成几个部分，比如四个分别为 25kb 的数据段。而每个数据段再加上一个 TCP 首部，就组成了 TCP 报文。 TCP 报文 (Segment)，包括首部和数据部分。 首部： 源端口 source port 目的端口 destination port 序号 sequence number 确认号 acknowledgment number 数据偏移 offset 保留 reserved 标志位 tcp flags 窗口大小 window size 检验和 checksum 紧急指针 urgent pointer 选项 tcp options HTTP 的缓存机制(常考)Http 的缓存主要利用 header 里的两个字段来控制： Cache-control主要包含以及几个字段： private:则只有客户端可以缓存 public:客户端和代理服务器都可以缓存 max-age:缓存的过期时间 no-cache:需要使用对比缓存来验证缓存数据 no-store:所有内存都不会进行缓存 ETag:即用来进行对比缓存，Etag 是服务端资源的一个标识码 当客户端发送第一次请求时服务端会下发当前请求资源的标识码 Etag，下次再请求时，客户端则会通过 header 里的 If-None-Match 将这个标识码 Etag 带上，服务端将客户端传来的 Etag 与最新的资源 Etag 做对比，如果一样，则表示资源没有更新，返回 304。 通过 Cache-control 和 Etag 的配合来实现 Http 的缓存机制。 CookieCookie 就是用来在本地缓存记住一些状态的，一个 Cookie 一般都包含 domin(所属域)、path、Expires(过期时间)等几个属性。服务端可以通过在响应头里的 set-cookies 来将状态写入客户端的 Cookie 里。下次客户端发起请求时可以将 Co Http 2.0 与 http1.x 相比有什么优点(常考) 二进制格式:http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request,使得网络传输变得十分灵活。 多路复用: 一个很大的改进，原先 http1.x 一个连接一个请求的情况有比较大的局限性，也引发了很多问题，如建立多个连接的消耗以及效率问题。 http1.x 为了解决效率问题，可能会尽量多的发起并发的请求去加载资源，然而浏览器对于同一域名下的并发请求有限制，而优化的手段一般是将请求的资源放到不同的域名下来突破这种限制。 而 http2.0 支持的多路复用可以很好的解决这个问题，多个请求共用一个 TCP 连接，多个请求可以同时在这个 TCP 连接上并发，一个是解决了建立多个 TCP 连接的消耗问题，一个也解决了效率的问题。那么是什么原理支撑多个请求可以在一个 TCP 连接上并发呢？基本原理就是上面的二进制分帧，因为每一帧都有一个身份标识，所以多个请求的不同帧可以并发的无序发送出去，在服务端会根据每一帧的身份标识，将其整理到对应的 request 中。 header 头部压缩:主要是通过压缩 header 来减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上 header，而这个 header 中的数据通常是一层不变的。 支持服务端推送 流量控制流量控制是对一条通信路径上的流量进行控制，就是发送方通过获取接收方的回馈来动态调整发送的速率，来达到控制流量的效果，其目的是保证发送者的发送速度不超过接收者的接收速度。 拥塞控制拥塞控制是对整个通信子网的流量进行控制，属于全局控制。 慢开始+拥塞避免 先来看一张经典的图： 一开始使用慢启动，即拥塞窗口设为 1，然后拥塞窗口指数增长到慢开始的门限值(ssthresh=16),则切换为拥塞避免,即加法增长，这样增长到一定程度，导致网络拥塞，则此时会把拥塞窗口重新降为 1，即重新慢开始，同时调整新的慢开始门限值为 12，之后以此类推。 快重传+快恢复 快重传:上面我们说的重传机制都是等到超时还未收到接收方的回复，才开始进行重传。而快重传的设计思路是：如果发送方收到 3 个重复的接收方的 ACK，就可以判断有报文段丢失，此时就可以立即重传丢失的报文段，而不用等到设置的超时时间到了才开始重传，提高了重传的效率。 快恢复：上面的拥塞控制会在网络拥塞时将拥塞窗口降为 1，重新慢开始，这样存在的一个问题就是网络无法很快恢复到正常状态。快恢复就是来优化这个问题的，使用快恢复，则出现拥塞时，拥塞窗口只会降低到新的慢开始门阀值（即 12），而不会降为 1，然后直接开始进入拥塞避免加法增长，如下图所示： 推荐阅读 WEB即时通信最佳实践 前端通信进阶 WebSocket 通信过程与实现","categories":[{"name":"生活","slug":"生活","permalink":"https://ioufev.com/categories/生活/"}],"tags":[{"name":"计算机协议","slug":"计算机协议","permalink":"https://ioufev.com/tags/计算机协议/"}]},{"title":"Hexo+NexT 打造一个炫酷博客","slug":"Hexo+NexT 打造一个炫酷博客","date":"2019-01-15T06:29:29.000Z","updated":"2020-01-01T07:48:56.793Z","comments":true,"path":"2019/01/15/hexo-next-da-zao-yi-ge-xuan-ku-bo-ke/","link":"","permalink":"https://ioufev.com/2019/01/15/hexo-next-da-zao-yi-ge-xuan-ku-bo-ke/","excerpt":"Hexo+NexT 打造一个炫酷博客","text":"Hexo+NexT 打造一个炫酷博客 原文作者：sun_xy原文标题：Hexo+NexT 打造一个炫酷博客原文地址：https://sun_xy.gitee.io/blog/2018/10/16/hexo_next_blog/ 写在前面本文主要是NexT主题配置以及页面的样式优化，参考了许多大佬的文章以及配置文件。 本文参考的文章都会直接给出原文链接或者以注脚的形式标记出处，但 Google 参考了实在太多太多了，如有遗漏，欢迎指出。 前期整个博客优化配置过程中收藏了许多很好的博客，回头可以贴个友情链接大家可以去看看。 本文内容会在后续的优化中慢慢补充完整： 新建日期：2018-10-16 更新日期: 2018-10-17 基本定义在 Hexo 中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 站点配置文件路径1~/hexo/_config.yml 主题配置文件路径1~/hexo/themes/next/_config.yml 博客搭建初级 基础功能篇站点配置文件最权威的当然是先看Hexo官方文档 下面是我在用的配置文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101## 站点设置title: 雜言非語subtitle: 成為一個厲害得普通人description: 小人物,码农keywords:author: Sun XYlanguage: zh-Hanstimezone:#主题设置theme: next# 博客地址## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://sun_xy.gitee.io/blog/root: /blogpermalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# 写作文章设置new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 5 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: # 日期格式/时间格式date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页设置## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page#RSS订阅是设置plugin: hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20# 发布部署地址设置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://gitee.com/Sun_xy/blog.git branch: master# 博客搜索功能配置search: path: search.xml field: post format: html limit: 10000# 文章推荐功能,需要安装插件recommended_posts: server: https://api.truelaurel.com #后端推荐服务器地址 timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式 internalLinks: 3 #内部文章数量 externalLinks: 1 #外部文章数量 fixedNumber: false autoDisplay: false #自动在文章底部显示推荐文章 excludePattern: [] titleHtml: &lt;h1&gt;推荐文章&lt;/h1&gt; #自定义标题 ###主题配置文件 最权威的当然是先看NexT使用文档 下面是我在用的配置文件: 配置文件参考了reuixiy大佬的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851# ---------------------------------------------------------------# Theme Core Configuration Settings# ---------------------------------------------------------------# 主题更新设置相关，参考：# https://github.com/iissnan/hexo-theme-next/issues/328override: false# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# 站点图标啦，直接去 https://realfavicongenerator.net# 选项弄好后，下载压缩包，解压复制粘贴# 建议放在 hexo-site/source/images/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦# 最后记得要稍微改下文件名，与下面的保持一致favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)# 站点关键字，利于 SEO 大概，记得用英文逗号分隔keywords: hexo,博客，生活，技术，代码# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.# RSS，节站点配置文件里面的注释配置# 则无需在这添加任何东西rss: /atom.xml# 页脚footer: # 建站年份 since: 2018 # 年份后面的图标，为 Font Awesome 图标 # 自己去纠结 https://fontawesome.com/v4.7.0/ # 然后更改名字就行，下面的有关图标的设置都一样 icon: sun-o # 如果不定义，默认用站点配置文件的 author 名 copyright: # ------------------------------------------------------------- # 是否显示Hexo link powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Any custom text can be defined here. # custom_text: Hosted by &lt;a target=\"_blank\" href=\"https://pages.github.com\"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# 菜单设置 || 菜单图标设置（图标上面说了，不重复）# 项目换行可以更改显示顺序# 如果这个项前会显示 .menu# 解决方法：编辑 ~/blog/themes/next/languages 下的相应文件# 比如添加一个“留言”菜单，站点配置文件的 language 是 zh-Hans# 则编辑 zh-Hans.yml，在 menu: 项内添加一行 留言: 留言# 注意空格，且符号 : 为英文字符！menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat# 是否开启菜单图标menu_icons: enable: true# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# 设计板式，都长啥样，去 README 里面的链接里看看# https://github.com/iissnan/hexo-theme-next#live-preview# Schemesscheme: Muse# scheme: Mist# scheme: Pisces# scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# 侧栏社交链接设置，与上面菜单差不多，要生效记得把前面的 # 去掉social: GitHub: https://github.com/Sun-xyu || github E-Mail: mailto:sun64146458@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype# 侧栏社交链接图标设置social_icons: enable: true icons_only: true transition: true# Blog rolls# 侧栏友链设置links_icon: listlinks_title: 近期文章links_layout: block#links_layout: inlinelinks: Hexo 搭建个人博客: https://sun_xy.gitee.io/blog/2018/10/14/Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif# 侧栏头像设置# 建议放在 hexo-site/source/uploads/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦avatar: /images/xiaorenwu.jpg # 侧栏文章目录设置toc: enable: true # 自动加数字序号 number: true # 如果标题太长，则放到下一行继续显示 # 开启后可能要在 custom.styl 里加代码 wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). # 侧栏位置设置，可用值：左 | 右（只对 Pisces 和 Gemini 设计版式有效！） # position: left position: right # Sidebar Display, available value (only for Muse | Mist): # 侧栏显示方式，post 代表只有点进一篇文章内 # 且文章有目录，侧栏才会弹出显示 # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # 只对 Pisces 和 Gemini 设计版式有效！ offset: 12 # 只对 Pisces 和 Gemini 设计版式有效 b2t: false # 在回到顶部按钮里显示阅读百分比 scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). # 移动端显示侧栏，只对 Muse 和 Mist 设计版式有效！ onmobile: true# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 点击 [Read More]，页面自动滚动到 &lt;!-- more --&gt; 标记处scroll_to_more: false# Automatically saving scroll position on each post/page in cookies.# 用 cookies 保存浏览的位置信息，意味着重新打开这个页面后# 页面就会自动滚动到上次的位置，除非读者清理浏览器 cookiessave_scroll: false# Automatically excerpt description in homepage as preamble text.# 将每篇文章 Front-matter 里 description 的文字作为页面显示的文章摘要excerpt_description: false# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 按字数自动加入 [Read More]，不建议！# 建议在文章中加入 &lt;!-- more --&gt;# 自定义 [Read More] 按钮之前要显示的内容！auto_excerpt: enable: false length: 150# Post meta display settings# 文章顶部显示的文章元数据设置post_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 显示统计字数和估计阅读时长# 注意：这个要安装插件，先进入站点文件夹根目录# 然后：npm install hexo-wordcount --savepost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true# Recommended posts# Dependency: https://github.com/huiwang/hexo-recommended-posts# Wechat Subscriber# 文章末尾显示微信二维码wechat_subscriber: enabled: false qcode: /blog/uploads/wechat-qcode.jpg description: 订阅博客# Reward# 文章末尾显示打赏功能#reward_comment: Donate comment here#wechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# 转载声明post_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.# 移动端把页面两边留白去除，个人不建议mobile_layout_economy: false# Android Chrome header panel color ($black-deep).# Android 上 Chrome 浏览器顶部颜色设置android_chrome_color: \"#222\"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 代码高亮主题设置# 都长啥样自己点开上面的链接查看highlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------# 字体设置font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: https://fonts.cat.net # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Roboto Slab size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID# 百度站点统计baidu_analytics: a452b4c4a1cd7c9a9f62d952a88dc832# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: false shortname: count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# 评论系统# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.# baidushare:# type: slide# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.# jiathis:# uid: Get this uid from http://www.jiathis.com/# add_this_id:# Share# duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru# 文章分享功能needmoreshare2: enable: true postbottom: enable: true options: iconStyle: default boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: true options: iconStyle: default boxForm: vertical position: topRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 可以显示每篇文章的阅读量# 然后可以通过阅读量建立 TopX 页面，教程链接：# https://www.jianshu.com/p/702a7aec4d00leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子统计，用于在页脚显示总访客数和总浏览量，将 false 改为 true 就能直接使用busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only # 页面浏览量，不建议开启，建议用上面的 leancloud_visitors # 首先 leancloud 更稳定，其次 leancloud 便于管理 # 最后，可以利用 leancloud 的 api 建立 TopX 页面 page_pv: false page_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; page_pv_footer: # Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" hits_stats: \"$&#123;hits&#125; results found in $&#123;time&#125; ms\"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-search# 要安装插件才能使用，先进入站点文件夹根目录# 然后：npm install hexo-generator-searchdb --savelocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url \"title\" %&#125;# Alias: &#123;% extlink text url \"title\" %&#125;# 用法见：# https://github.com/iissnan/hexo-theme-next/pull/1438exturl: false# Note tag (bs-callout).# 主题的标签样式，有 note、label、tabs 三种note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. # 风格 style: flat # 要不要图标 icons: false # 圆角矩形 border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.# 页面顶部加载条pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# 动态效果# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.# 相关内容用 CDN 地址取代，加速网站访问，注意版本尽可能要一致vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4 进阶 网页样式篇需要了解的浏览器按 F12 即可，建议用Google Chrome 浏览器调试。 自定义样式文件 :themes\\next\\source\\css\\_custom\\custom.styl 修改文件后直接保存，刷新页面即可查看效果。 修改文章页宽打开themes/next/source/css/_variables/base.styl，找到以下字段并修改为合适的宽度： 12- $content-desktop-large = 900px+ $content-desktop-large = 1000px 修改小型代码块颜色修改\\themes\\next\\source\\css\\ _variables\\base.styl文件，加入自定义颜色： 123456789$black-deep = #222$red = #ff2a2a$blue-bright = #87daff$blue = #0684bd$blue-deep = #262a30$orange = #fc6423// 自定义的颜色+ $single-line-code-foreground = #dd0055 // 用``围出的代码块字体颜色+ $single-line-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值： 123456789// Code &amp; Code Blocks$code-font-family = $font-family-monospace$code-font-size = 13px$code-font-size = unit(hexo-config('font.codes.size'), px) if hexo-config('font.codes.size') is a 'unit'$code-border-radius = 4px- $code-foreground = $black-light- $code-background = $gainsboro+ $code-foreground = $single-line-code-foreground+ $code-background = $single-line-code-background 修改themes\\next\\source\\css\\_custom\\custom.styl文件，加入自定义样式 12345// 文章``代码块的自定义样式code &#123; margin: 0px 2px; border: 1px solid #999;&#125; 修改链接文字样式修改themes\\next\\source\\css\\_custom\\custom.styl文件，加入自定义样式 123456789101112// 文章内链接文本样式.post-body a &#123; // 链接文字颜色 color: #0593d3; // 去掉下划线：下划线效果是用下边框实现的，去掉即可 border-bottom: none; &amp;:hover &#123; // 鼠标悬停时链接文字颜色 color: #fc6423; &#125;&#125; 修改[Read More]按钮样式修改themes\\next\\source\\css\\_custom\\custom.styl文件，加入自定义样式 12345678910111213141516171819// [Read More]按钮样式.post-button .btn &#123; color: #555 !important; background-color: rgb(255, 255, 255); border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); border: none !important; transition-property: unset; padding: 0px 15px;&#125;.post-button .btn:hover &#123; color: rgb(255, 255, 255) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125; 修改标签云（tagcloud）的颜色修改themes/next/layout/page.swig文件，加入自定义样式: 12- &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125;+ &#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &apos;#9733EE&apos;, end_color: &apos;#FF512F&apos;&#125;) &#125;&#125; 修改对应参数值即可，参数说明见 Hexo官方文档 修改文章底部#号标签,改为图标修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 头像设置圆形,停留旋转效果修改themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author.styl,新增以下代码: 123456789101112131415.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; //设置圆形+ border-radius: 50%;+ transition: 2s all;&#125; //旋转+ .site-author-image:hover&#123;+ transform: rotate(360deg);+ &#125; 隐藏底部”强力驱动”内容修改themes/next/_config.yml文件,将powered和enable设置为false 12345678910111213141516171819202122# 页脚footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. # icon: user icon: sun-o # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo).- powered: true+ powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme).- enable: true+ enable: false # Version info of NexT after scheme info (vX.X.X). version: true 文章末尾添加”本文结束”标记修改在themes/next/layout/_macro/post.swig中，在wechat-subscriber.swig之前添加如下代码：123456+ &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;---------------- The End ----------------&lt;/div&gt; &#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &lt;/div&gt; &#123;% endif %&#125; 文章末尾追加版权信息增加版权有两种方式 修改主题配置文件,搜索post_copyright 12345post_copyright:- enable: false+ enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 如果觉得默认不好看,则可以自定义样式,找到themes/next/layout/_macro/post.swig，在footer之前添加如下代码(添加之前确保已添加样式)： 12345678&lt;div&gt; &lt;p id=&quot;div-border-left-red&quot;&gt; &lt;b&gt;本文基于&lt;a target=&quot;_blank&quot; title=&quot;Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;国际许可协议发布&lt;/b&gt;&lt;br/&gt; &lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br/&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 添加背景图片通过 jquery-backstretch，具体操作呢，编辑文件/themes/next/layout/_layout.swig，加入到文件最后面前面即可。1234+ &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt;;+ &lt;script&gt;+ $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;);+ &lt;/script&gt; 移动端显示 back-to-top 按钮和侧栏具体手机显示可用手机访问我的博客 我的博客主题是Muse，主题的设计模版是 Muse 或 Mist，就可以直接在主题配置文件中配置： 修改主题配置themes/next/_config.yml 12# Enable sidebar on narrow viewonmobile: true 如何调试手机样式页面，请自行查询 页面调试好之后将代码复制到:themes\\next\\source\\css\\_custom\\custom.styl 附上我的custom.styl样式文件不建议全部复制粘贴使用，最好是F12打开，根据关键ID找到对应的样式，复制到自己的文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407// Custom styles./*******************首页样式*****************************/// 顶栏宽度.container .header-inner &#123; width: 100%;&#125;// .headband &#123;// height: 1.5px;// background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);// &#125;// 页面顶部行高.header &#123; line-height: 1.5;&#125;// // 页面背景色// .container &#123;// background-color: rgba(0, 0, 0, 0.75);// &#125;// 页面留白更改.header-inner &#123; padding-top: 35px; padding-bottom: 0px;&#125;.posts-expand &#123; padding-top: 50px;&#125;.posts-expand .post-meta &#123; margin: 5px 0px 0px 0px;&#125;.post-button &#123; margin-top: 0px;&#125;// 顶栏宽度.container .header-inner &#123; width: 100%;&#125;// 渐变菜带，CSS代码copy自https://githubuniverse.com// .site-meta &#123;// background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);// &#125;//缩略图指定宽度值显示。img.img-topic &#123; width: 75%;&#125;/*******************文章样式*****************************/// 文章.post &#123; margin-bottom: 50px; padding: 45px 36px 36px 36px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255);&#125;// 文章标题字体.posts-expand .post-title &#123; font-size: 26px; font-weight: 700;&#125;// 文章标题动态效果.posts-expand .post-title-link::before &#123; background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;// 文章元数据（meta）留白更改.posts-expand .post-meta &#123; margin: 10px 0px 20px 0px;&#125;// 文章的描述description.posts-expand .post-meta .post-description &#123; font-style: italic; font-size: 14px; margin-top: 30px; margin-bottom: 0px; color: #666;&#125;// [Read More]按钮样式.post-button .btn &#123; color: #555 !important; background-color: rgb(255, 255, 255); border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); border: none !important; transition-property: unset; padding: 0px 15px;&#125;.post-button .btn:hover &#123; color: rgb(255, 255, 255) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;// 去除在页面文章之间的分割线.posts-expand .post-eof &#123; margin: 0px; background-color: rgba(255, 255, 255, 0);&#125;// 去除页面底部页码上面的横线.pagination &#123; border: none; margin: 0px;&#125;// 文章内标题样式（左边的竖线）.post-body h2, h3, h4, h5, h6 &#123; border-left: 4px solid rgb(161, 102, 171); margin-left: -36px; padding-left: 32px;&#125;// 去掉图片边框.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;// 文章``代码块的自定义样式code &#123; margin: 0px 3px; border: 1px solid #999;&#125;// 文章```代码块顶部样式.highlight figcaption &#123; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9;&#125;.highlight figcaption a &#123; color: rgb(80, 115, 184);&#125;// 文章```代码块diff样式pre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125;//文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;// 自定义的文章摘要图片样式img.img-topic &#123; width: 100%;&#125;/*************************侧栏样式****************************/// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125;// 右下角侧栏按钮样式.sidebar-toggle &#123; right: 10px; bottom: 43px; background-color: rgba(247, 149, 51, 0.75); border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.page-post-detail .sidebar-toggle-line &#123; background: rgb(7, 179, 155);&#125;// 右下角返回顶部按钮样式.back-to-top &#123; line-height: 1.5; right: 10px; padding-right: 5px; padding-left: 5px; padding-top: 2.5px; padding-bottom: 2.5px; background-color: rgba(247, 149, 51, 0.75); border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;// 侧栏.sidebar &#123; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgba(0, 0, 0, 0.75);&#125;.sidebar-inner &#123; margin-top: 30px;&#125;// 侧栏顶部文字.sidebar-nav li &#123; font-size: 15px; font-weight: bold; color: rgb(7, 179, 155);&#125;.sidebar-nav li:hover &#123; color: rgb(161, 102, 171);&#125;.sidebar-nav .sidebar-nav-active &#123; color: rgb(7, 179, 155); border-bottom-color: rgb(161, 102, 171); border-bottom-width: 1.5px;&#125;.sidebar-nav .sidebar-nav-active:hover &#123; color: rgb(7, 179, 155);&#125;// 侧栏站点作者名.site-author-name &#123; display: none;&#125;// 侧栏站点描述.site-description &#123; letter-spacing: 5px; font-size: 15px; font-weight: bold; margin-top: 15px; margin-left: 13px; color: rgb(243, 112, 85);&#125;// 侧栏站点文章、分类、标签.site-state &#123; line-height: 1.3; margin-left: 12px;&#125;.site-state-item &#123; padding: 0px 15px; border-left: 1.5px solid rgb(161, 102, 171);&#125;// 侧栏RSS按钮样式.feed-link &#123; margin-top: 15px; margin-left: 7px;&#125;.feed-link a &#123; color: rgb(255, 255, 255); border: 1px solid rgb(158, 158, 158) !important; border-radius: 15px;&#125;.feed-link a:hover &#123; background-color: rgb(161, 102, 171);&#125;.feed-link a i &#123; color: rgb(255, 255, 255);&#125;// 侧栏社交链接.links-of-author &#123; margin-top: 0px;&#125;// 侧栏友链标题.links-of-blogroll-title &#123; margin-bottom: 10px; margin-top: 15px; color: rgba(7, 179, 155, 0.75); margin-left: 6px; font-size: 15px; font-weight: bold;&#125;// 侧栏超链接样式（友链的样式）.sidebar a &#123; color: #ccc; border-bottom: none;&#125;.sidebar a:hover &#123; color: rgb(255, 255, 255);&#125;// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125;// 侧栏目录链接样式.post-toc ol a &#123; color: rgb(7, 179, 155); border-bottom: 1px solid rgb(96, 125, 139);&#125;.post-toc ol a:hover &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;// 侧栏目录链接样式之当前目录.post-toc .nav .active &gt; a &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;.post-toc .nav .active &gt; a:hover &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;/* 修侧栏目录bug，如果主题配置文件_config.yml的toc是wrap: true */.post-toc ol &#123; padding: 0px 10px 5px 10px;&#125;/* 侧栏目录默认全展开，已注释.post-toc .nav .nav-child &#123; display: block;&#125;*//************************移动端样式*******************************/@media (max-width: 1023px) &#123; .container &#123; background-color: rgba(0, 0, 0, 0); &#125; .sidebar &#123; // box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); border-top-left-radius: 5px; border-bottom-left-radius: 5px; &#125; .feed-link &#123; display: none !important; &#125;&#125;@media (max-width: 767px) &#123; .main &#123; padding-bottom: 120px; &#125; .posts-expand &#123; margin: 0px; padding-top: 10px; &#125; .posts-expand .post-title &#123; font-size: 22px; &#125; .posts-expand .post-meta &#123; font-size: 10px; &#125; .post &#123; margin-bottom: 30px !important; padding: 20px 15px 15px 15px !important; &#125; .post-body h2, h3, h4, h5, h6 &#123; margin-left: -15px; padding-left: 11px; &#125; .posts-expand .post-tags &#123; margin-top: 10px; &#125; .post-widgets &#123; margin-top: 10px; &#125; .comments &#123; margin: 40px 0px 40px 0px !important; &#125; .footer &#123; // box-shadow: 0px -5px 10px 0px rgba(0, 0, 0, 0.5); &#125;&#125;.sidebar-active #sidebar-dimmer &#123; opacity: 0;&#125;// 移动端左上角菜单按钮.site-nav-toggle &#123; top: 35px; left: 91px; // background-color: #222;&#125;.btn-bar &#123; background-color: rgb(255, 255, 255);&#125;// 移动端菜单@media (max-width: 767px) &#123; .menu &#123; text-align: center; // box-shadow: 0px 5px 10px 0px rgba(0, 0, 0, 0.5); &#125; .site-nav &#123; top: initial; background-color: rgba(255, 255, 255, 0.75); border-top: none; border-bottom: none; position: relative; z-index: 1024; &#125;&#125;//移动端顶部@media (max-width: 767px) &#123; .site-title &#123; font-size: 28px !important; letter-spacing: 0px !important; &#125; .site-subtitle&#123; letter-spacing: 0px !important; padding-bottom: 0px !important; &#125; .site-meta &#123; // box-shadow: 0px 5px 10px 0px rgba(0, 0, 0, 0.5); &#125; .menu .menu-item &#123; margin: 0px 10px !important; &#125;&#125; 进阶 高级功能配置设置动态titlethemes/next/source/js/src下创建dytitle.js：12345678910111213141516var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel=\"shortcut icon\"]').attr('href', \"/TEP.png\"); document.title = 'w(ﾟДﾟ)w 出BUG啦！！！！'; clearTimeout(titleTime); &#125; else &#123; $('[rel=\"shortcut icon\"]').attr('href', \"/favicon.png\"); document.title = '♪(^∇^*)又好了。。。 ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 修改themes/next/layout/layout.swing,在 之前添加： 121&lt;script type=\"text/javascript\" src=\"/js/src/dytitle.js\"&gt;&lt;/script&gt; 侧栏加入已运行的时间修改文件:themes/next/layout/_custom/sidebar.swig，加入一下代码： BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;);日期修改为自己的 1234567891011121314151617181920212223242526&lt;div id=\"days\"&gt;&lt;/div&gt;&lt;script&gt;function show_date_time()&#123;window.setTimeout(\"show_date_time()\"， 1000);BirthDay=new Date(\"05/27/2017 15:13:14\");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML=\"已运行\"+daysold+\"天\"+hrsold+\"小时\"+minsold+\"分\"+seconds+\"秒\";&#125;function setzero(i)&#123;if (i&lt;10)&#123;i=\"0\" + i&#125;;return i;&#125;show_date_time();&lt;/script&gt; 修改文件themes/next/layout/_macro/sidebar.swig 1234567891011121314151617181920 &#123;# Blogroll #&#125; &#123;% if theme.links %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.links_layout | default(&apos;inline&apos;) &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &#123;&#123; theme.links_title &#125;&#125;&amp;nbsp; &lt;i class=&quot;fa fa-fw fa-&#123;&#123; theme.links_icon | default(&apos;globe&apos;) | lower &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% for name, link in theme.links %&#125; &lt;li class=&quot;links-of-blogroll-item&quot;&gt; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;+ &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; &lt;/div&gt; &#123;% endif %&#125;- &#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 点击出现爱心效果在/themes/next/source/js/love.js下新建文件love.js，接着把该链接下的代码拷贝粘贴到love.js文件中1!function (e, t, a) &#123; function n() &#123; c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++)d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y-- , d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = \"left:\" + d[e].x + \"px;top:\" + d[e].y + \"px;opacity:\" + d[e].alpha + \";transform:scale(\" + d[e].scale + \",\" + d[e].scale + \") rotate(45deg);background:\" + d[e].color + \";z-index:99999\"); requestAnimationFrame(r) &#125; function o() &#123; var t = \"function\" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement(\"div\"); a.className = \"heart\", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement(\"style\"); a.type = \"text/css\"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName(\"head\")[0].appendChild(a) &#125; function s() &#123; return \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n() &#125;(window, document); 在\\themes\\next\\layout_layout.swig文件末尾添加：12345&#123;% include '_third-party/exturl.swig' %&#125;+ &lt;!-- 页面点击小红心 --&gt;+ &lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击头像回到博客首页修改文件/themes/next/layout/_macro/sidebar.swig,增加以下代码:12345+ &lt;a href=\"/\"&gt; &lt;img class=\"site-author-image\" itemprop=\"image\" src=\"&#123;&#123; url_for( theme.avatar | default(theme.images + '/avatar.gif') ) &#125;&#125;\" alt=\"&#123;&#123; theme.author &#125;&#125;\" /&gt;+ &lt;/a&gt; 增加内容分享服务修改themes/next/_config.yml主题配置文件，搜索关键字needmoreshare2，找到如下代码并做以下修改:1234567891011121314151617# 文章分享功能needmoreshare2: enable: true postbottom: enable: true options: iconStyle: default boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: true options: iconStyle: default boxForm: vertical position: topRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 关于分享中的微信二维码图片加载失败,感谢Qcmoke大佬的解决方案 next 5.1.4版本中微信加载不出二维码,应该是封装好的微信分享链接失效了。我是通过老版本的仓库https://github.com/iissnan/hexo-theme-next 安装的，所以有这个问题，而新版本的next是没有这个问题的。新版本仓库已经搬迁到了https://github.com/theme-next 输入以下命令：12rm -rf themes/next/source/lib/needsharebuttongit clone https://github.com/theme-next/theme-next-needmoreshare2 themes/next/source/lib/needsharebutton 增加站内文章搜索功能安装插件hexo-generator-searchdb,执行以下命令:1npm install hexo-generator-searchdb --save 修改hexo/_config.yml站点配置文件,末尾新增以下代码:12345search: path: search.xml field: post format: html limit: 10000 修改themes/next/_config.yml主题配置文件，搜索关键字local_search找到如下代码，将enable设置为true，如下：12local_search: enable: true 增加文章字数统计及阅读时常功能安装插件hexo-wordcount,执行以下命令:1npm install hexo-wordcount --save 修改themes/next/_config.yml主题配置文件，搜索关键字post_wordcount,修改如下:123456post_wordcount: item_text: true wordcount: true #单篇文章字数 min2read: true #单篇阅读时长 totalcount: true #站点总字数 separated_meta: true 增加站点访问统计功能next主题默认集成了第三方访问统计插件。 修改themes/next/_config.yml主题配置文件，搜索关键字busuanzi_count:12345678910111213141516171819# 不蒜子统计，用于在页脚显示总访客数和总浏览量，将 false 改为 true 就能直接使用busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only # 页面浏览量，不建议开启，建议用上面的 leancloud_visitors # 首先 leancloud 更稳定，其次 leancloud 便于管理 # 最后，可以利用 leancloud 的 api 建立 TopX 页面 page_pv: false page_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; page_pv_footer: 目前不蒜子『dn-lbstatics.qbox.me』域名过期，更换域名到『busuanzi.ibruce.info』！故你可能需要修改&gt;以下文件相关信息：修改themes/next/layout/_third-party/analytics/busuanzi-counter.swig文件，找到dn-lbstatics.qbox.me,修改代码：1&lt;script async src=\"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 文章置顶功能移除默认安装的插件：1npm uninstall hexo-generator-index --save 安装新插件:1npm install hexo-generator-index-pin-top --save 最后编辑有这需求的相关文章时，在Front-matter（文件最上方以—分隔的区域）加上一行：top: true如果你置顶了多篇，怎么控制顺序呢？设置top的值（大的在前面），比如：1234567# Post a.mdtitle: atop: 1# Post b.mdtitle: btop: 10 文章 b 便会显示在文章 a 的前面。 LeanCloud统计文章阅读数 已有大佬提供,具体详情请戳进Hexo博客-NexT主题：使用leancloud进行页面访客统计 添加 TopX 页面评论系统关于主题更新升级对于升级主题，我们需要重新配置主题配置文件，那么每次升级都要这么干吗？超麻烦！ NexT作者给我们的建议就是使用Data Files，具体详情请戳进 Theme configurations using Hexo data files #328 贴出以下总结: 请先确保你所使用的 Hexo 版本在 3 以上 在站点的 source/_data 目录下新建 next.yml 文件（_data目录可能需要新建） 迁移站点配置文件和主题配置文件中的配置到 next.yml 中 所有主题相关的配置都可以写到 next.yml 文件中。 主题目录下的 _config.yml 可以不用做任何修改。 若你是新安装的，可以将主题的 _config.yml 里面的内容整个拷贝过去，然后修改即可 若是之前有将配置写在站点的 _config.yml 里，把这个文件里主题相关的配置剪切到 next.yml 里去;同时将主题下 _config.yml 里面的配置也拷贝过去，相当于是全部合并到 next.yml 中去了。 每次修改 _next.yml 需要重启 hexo server 才能生效。 进阶 文章篇写在最后","categories":[{"name":"生活","slug":"生活","permalink":"https://ioufev.com/categories/生活/"}],"tags":[{"name":"next","slug":"next","permalink":"https://ioufev.com/tags/next/"}]}]}